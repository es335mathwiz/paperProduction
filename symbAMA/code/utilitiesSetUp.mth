$antlrPath="/msu/res1/Software/mavenRepositories/tryRep/org/antlr/antlr-runtime/3.2/antlr-runtime-3.2.jar";
$dynareParserPath="../../DynareParsers/target/classes/";
$dynareParserPath="/msu/home/m1gsa00/git/DynareParsers/target/classes/";
$symPath="../../mathAMA/SymbolicAMA/SymbolicAMA/";
$numPath="../../mathAMA/NumericAMA/NumericAMA/";
$modPath="../../mathAMA/AMAModel/";
$fmtPath="../../FormatOptimize/";
$Path = Join[$Path, {$symPath,$numPath,$modPath,$fmtPath}];
Needs["AccelerateAMA`"]

Print["utilitiesSetUp.mth: after parser stable go back to relative path"]
AddToClassPath[$antlrPath];
AddToClassPath[$dynareParserPath];

theDynareMods=FileBaseName/@FileNames[{___~~".mod"},{"dynareExamples/uniqueExamples/"}];


src["AltEx1"]="Collard";
src["AssetPricingApproximation"]="Barillas";
src["AssetPricingEstimate"]="Barillas";
src["bkk"]="Dynare";
src["example1"]="Dynare";
src["example2"]="Dynare";
src["fs2000"]="Dynare";
src["fs2000_nonstationary"]="Dynare";
src["ramst"]="Dynare";
src["BansalYaronBayes"]="Barillas";;
src["BansalYaronML"]="Barillas";;
src["BGGViegi"]="Viegi";
src["Fig1131commented"]="Barillas";
src["Fig1131"]="Barillas";
src["Fig1132"]="Barillas";
src["Fig1151"]="Barillas";
src["Fig1152"]="Barillas";
src["Fig1171"]="Barillas";
src["Fig1172"]="Barillas";
src["Figv3_1161"]="Ljungqvist";
src["Figv3_1162"]="Ljungqvist";
src["Figv3_1163"]="Ljungqvist";
src["Figv3_1164"]="Ljungqvist";
src["Figv3_1165"]="Ljungqvist";
src["Figv3_1166"]="Ljungqvist";
src["Figv3_1191"]="Ljungqvist";
src["Figv3_1192"]="Ljungqvist";
src["Figv3_1193"]="Ljungqvist";
src["firmValue"]="FRB";
src["fs2000ns"]="Dynare";
src["fuhrerMoore"]="FRB";
src["GrowthApproximate"]="Barillas";
src["GrowthEstimate"]="Barillas";
src["hall1estimateBayes"]="Barillas";
src["hall1estimateML"]="Barillas";
src["hall1"]="Barillas";
src["HSTBayes"]="Barillas";
src["HSTML"]="Barillas";
src["ifs1"]="Ngalawa";
src["kiyotakiMooreViegi"]="Viegi";
src["lesothoViegi"]="Viegi";
src["lubikSchorfheide"]="";
src["RBC_Est"]="Dynare";
src["RBCEst"]="Dynare";
src["RBCMonopDet"]="Dynare";
src["RBCMonopJFV"]="Dynare";
src["RBCViegi"]="Viegi";
src["rosenestimateBayes"]="Barillas";
src["rosenestimateML"]="Barillas";
src["rosen"]="Barillas";
src["sargent77Bayes"]="Barillas";
src["sargent77ML"]="Barillas";
src["sargent77"]="Barillas";
src["simpleNeoViegi"]="Viegi";
src["TwocountryApprox"]="Barillas";
src["TwocountryEst"]="Barillas";
src["lubikSchorfheide"]="Lubik";
src["GLLSELB"]="Gust";






trySolveSS[eqns_List,vars_List]:=
Module[{},
ssEqns=eqns//.ssSubs;
someSSSubs=TimeConstrained[Solve[Thread[ssEqns==0],vars],$tConst];
If[FreeQ[someSSSubs,Solve],someSSSubs/.
(#->ToExpression[ToString[#]<>"SSVal"]&/@vars),{}
]]



allLinear[theDir_String,modName_String,targDir_String]:=
Module[{parseTime,vars,ig,params,eqns,notSubs,paramSubs,
hmatTime,hmat,
arTime,zf,hf,
amatTime,amat,
lilTime,lilMat,cols,
evalsTime,evals,
lilevecsTime,lilevecs,
evecsTime,evecs,
bmatTime,bmat,
sTime,theS},
Print["parsing " <>modName];
{parseTime,{vars,ig,params,ig,{ig,eqns},notSubs,ig}}=
Timing[parseMod[theDir,modName,targDir]];
paramSubs=#[[1]]->#[[2]]&/@params;
Print["gen hmat"];
{hmatTime,hmat}=Timing[equationsToMatrix[eqns,vars]];
Print["gen symbolicAR"];
{arTime,{zf, hf}} = Timing[symbolicAR[hmat]];
Print["gen amat"];
{amatTime,amat} = Timing[symbolicTransitionMatrix[hf]];
Print["shrink hmat"];
{lilTime,{lilMat,cols}}=
Timing[symbolicEliminateInessentialLags[{amat,Range[Length[amat]]}]];
Print["gen eigenvalues"];
{evalsTime,evals}= Timing[Eigenvalues[Transpose[lilMat]]];
Print["gen evecs"];
{lilevecsTime,lilevecs}=Timing[compEigSpace[lilMat,evals,paramSubs]];
{evecsTime,evecs}=Timing[toLarge[lilevecs,cols,Length[zf[[1]]]]];
Print["compute bmat"];
{bmatTime,bmat}=Timing[compB[zf,evecs,Length[hmat]]];
Print["gen smat"];
{sTime,theS}=Timing[obStruct[hmat,bmat]];
{parseTime,hmatTime,arTime,amatTime,lilTime,evalsTime,lilevecsTime,evecsTime,bmatTime,sTime,paramSubs,eqns,bmat,theS,hmat,vars}
]

allNonLinear[theDir_String,modName_String,targDir_String]:=
Module[{parseTime,vars,ig,params,eqns,notSubs,paramSubs,
hmatTime,hmat,
arTime,zf,hf,
amatTime,amat,
lilTime,lilMat,cols,
evalsTime,evals,
lilevecsTime,lilevecs,
evecsTime,evecs,
bmatTime,bmat,
sTime,theS},
{parseTime,{vars,ig,params,ig,{ig,eqns},notSubs,ig}}=
Timing[parseMod[theDir,modName,targDir]];
paramSubs=#[[1]]->#[[2]]&/@params;
{solveTime,solveSoln}=Timing[trySolveSS[eqns,vars]];
{fRootTime,fRootSoln}=Timing[makeSomeSSSubs[modName]];
{hmatTime,hmat}=Timing[equationsToMatrix[eqns,vars]/.makeSSValSubs[vars]];
{arTime,{zf, hf}} = Timing[symbolicAR[hmat]];Print["done ar"];
{amatTime,amat} = Timing[symbolicTransitionMatrix[hf]];
{lilTime,{lilMat,cols}}=
Timing[symbolicEliminateInessentialLags[{amat,Range[Length[amat]]}]];Print["done inessential"];
{more,lilMat}=Timing[FullSimplify[lilMat,TimeConstraint->$tConst]];lilTime=lilTime+more;
{evalsTime,evals}= Timing[TimeConstrained[Eigenvalues[Transpose[lilMat]],$tConst]];Print["done evals"];
{lilevecsTime,lilevecs}=Timing[TimeConstrained[compEigSpace[lilMat,evals,Join[paramSubs,fRootSoln]],$tConst]];
{evecsTime,evecs}=Timing[toLarge[lilevecs,cols,Length[zf[[1]]]]];
{bmatTime,bmat}=Timing[compB[zf,evecs,Length[hmat]]];
{sTime,theS}=Timing[obStruct[hmat,bmat]];
{parseTime,hmatTime,arTime,amatTime,lilTime,evalsTime,lilevecsTime,evecsTime,bmatTime,sTime,solveTime,fRootTime,paramSubs,eqns,bmat,theS,solveSoln,fRootSoln,hmat,vars}
]



Get["genMexCode.mth"]

makeSSValSubs[modName_String]:=makeSSValSubs[getVars[modName]]


compB[zf_?MatrixQ,{},neq_Integer]:={}

compB[zf_?MatrixQ,evs_?MatrixQ,neq_Integer]:=
With[{qmat=Join[zf,evs]},
With[{qcols=Length[qmat[[1]]],qrows=Length[qmat]},
With[{qr=qmat[[All,qcols-qrows+Range[qrows]]],
ql=qmat[[All,Range[qcols-qrows]]]},
(-Inverse[qr].ql)]]]

toLarge[{},lilCols_List,cols_Integer]:={}

toLarge[lil_?MatrixQ,lilCols_List,cols_Integer]:=
Module[{bigEvecs},
bigEvecs=ConstantArray[0,{Length[lil],cols}];
bigEvecs[[All,lilCols]]=lil;
bigEvecs]

obStruct[hmat_?MatrixQ,bigB_?MatrixQ]:=
With[{neq=Length[hmat],lTau=Length[bigB[[1]]],lTheta=Length[bigB]},
With[{hMinus=hmat[[All,Range[lTau+neq]]],
hPlus=hmat[[All,lTau+neq+Range[lTheta]]]},
hMinus+blockMatrix[{{zeroMatrix[neq],hPlus . bigB}}]]]






allPhiF[theDir_String,modName_String,targDir_String]:=
Module[{parseTime,vars,ig,params,eqns,notSubs,paramSubs,
hmatTime,hmat,qmat,phiMat,fMat,
arTime,zf,hf,
amatTime,amat,
lilTime,lilMat,cols,
evalsTime,evals,
lilevecsTime,lilevecs,
evecsTime,evecs,
bmatTime,bmat,
sTime,theS},
Print["parsing " <>modName];
{parseTime,{vars,ig,params,ig,{ig,eqns},notSubs,ig}}=
Timing[getModelDims[theDir,modName,targDir]];
paramSubs=#[[1]]->#[[2]]&/@params;
Print["gen hmat"];
{hmatTime,hmat}=Timing[equationsToMatrix[eqns,vars]];
Print["gen symbolicAR"];
{arTime,{zf, hf}} = Timing[symbolicAR[hmat]];
Print["gen amat"];
{amatTime,amat} = Timing[symbolicTransitionMatrix[hf]];
Print["shrink hmat"];
{lilTime,{lilMat,cols}}=
Timing[symbolicEliminateInessentialLags[{amat,Range[Length[amat]]}]];
Print["gen eigenvalues"];
{evalsTime,evals}= Timing[Eigenvalues[Transpose[lilMat]]];
Print["gen evecs"];
{lilevecsTime,lilevecs}=Timing[compEigSpace[lilMat,evals,paramSubs]];
{evecsTime,evecs}=Timing[toLarge[lilevecs,cols,Length[zf[[1]]]]];
Print["compute bmat phimat fmat"];
qmat=Join[zf,evecs];
{bmatTime,{bmat,phiMat,fMat}}=Timing[symbolicComputeBPhiF[hmat,qmat]];
Print["gen smat"];
{sTime,theS}=Timing[obStruct[hmat,bmat]];
{parseTime,hmatTime,arTime,amatTime,lilTime,evalsTime,lilevecsTime,evecsTime,bmatTime,sTime,paramSubs,eqns,bmat,phiMat,fMat,theS,hmat,vars}
]







isLin[modName_String]:=Not[FreeQ[allLinearMods,modName]]
isNonLin[modName_String]:=Not[FreeQ[allNonLinearMods,modName]]



getVars[modName_String]:=If[isLin[modName],getLinVars[modName],
If[isNonLin[modName],getNonLinVars[modName],"unknown model"]]


getEqns[modName_String]:=If[isLin[modName],getLinEqns[modName],
If[isNonLin[modName],getNonLinEqns[modName],"unknown model"]]

getHmat[modName_String]:=If[isLin[modName],getLinHmat[modName],
If[isNonLin[modName],getNonLinHmat[modName],"unknown model"]]


getB[modName_String]:=If[isLin[modName],getLinB[modName],
If[isNonLin[modName],getNonLinB[modName],"unknown model"]]

getS[modName_String]:=If[isLin[modName],getLinS[modName],
If[isNonLin[modName],getNonLinS[modName],"unknown model"]]

getParamSubs[modName_String]:=If[isLin[modName],getLinParamSubs[modName],
If[isNonLin[modName],getNonLinParamSubs[modName],"unknown model"]]

getParams[modName_String]:=Sort[First /@ getParamSubs[modName]]





(*

$tConst=10;

forMex=allNonLinear["dynareExamples/uniqueExamples/",#,"theLinRes/"]& /@ smallLinearMods;

mexComp/@ smallLinearMods;
expHMat/@ smallLinearMods;
*)



(*




*)
