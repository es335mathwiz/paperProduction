%"C:\Program Files\Wolfram Research\Mathematica\9.0\math.exe"
%\documentclass[pdf]{beamer}
%set BIBINPUTS=.;../../bibFiles;;
%set TEXINPUTS=.;../../texFiles;../../bibFiles;;
%pdflatex sce2014Slides
%'/msu/home/m1gsa00/git/paperProduction/symbAMA/docs/sce2014Slides.tex--2014-08-06 12:29:29 EDT'
%'/msu/home/m1gsa00/git/paperProduction/symbAMA/docs/sce2014Slides.tex--2014-08-06 12:29:29 EDT'
%'/msu/home/m1gsa00/git/paperProduction/DSGECodeGen/docs/sce2014Slides.tex--2014-06-12 09:37:14 EDT'
%'/msu/home/m1gsa00/git/mathSmolyak/docs/smolyakSlides.tex--2014-08-07 10:01:46 EDT'
%'/msu/home/m1gsa00/git/paperProduction/symbAMA/docs/hybridSymbolicProjectionAMA.tex--2014-08-06 07:24:09 EDT'


%\documentclass[tikz]{beamer}

\documentclass[handout]{beamer}
  \usepackage{pgfpages}
\mode<handout>{\setbeamercolor{background canvas}{bg=black!20}}
\pgfpagesuselayout{2 on 1}[letterpaper,border shrink=5mm]
%\usepackage{handoutWithNotes}
%\pgfpagesuselayout{4 on 1 with notes}[a4paper,border shrink=5mm]
%
%  Load other packages you may need here
% 
% \pgfpagesuselayout{4 on 1}[a4paper,landscape,border shrink=5mm


\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\mode<presentation>{}
\usepackage{pseudocode}
\usepackage{dirtree}
\usepackage{beamerthemeshadow}
\usepackage[utf8]{inputenc}
\usepackage{listings,xcolor}


\usepackage{moreverb}
\usepackage{ulem}
\usepackage{soul}
%\usepackage{algorithmicx}
%\usepackage{algpseudocode}
%\usepackage{pseudocode}
\usepackage{hyperref}
% \usepackage{color}
% \definecolor{light}{gray}{.80}
% \usepackage{graphicx}
% \usepackage{amsfonts}
% \usepackage{amsmath}
% \usepackage{amssymb}
% \usepackage{amsthm}
% \usepackage{algorithmicx}
%\usepackage{program}
% \usepackage{rotating}
\usepackage{ulem}
\usepackage{authordate1-4}
%\input{someNewCommands}
\newcommand{\mma}{Mathematica}
\begin{document}
\title[The Anisotropic Smolyak Method]{The Judd, Maliar, Maliar and Valero Anisotropic Smolyak Method}
%\subtitle{this is a subtitle}


\author{Gary S. Anderson}
\date{\today} 


\frame{\titlepage}


\section{Overview}



\begin{frame}
  \frametitle{Overview}
  
  \begin{itemize}
  \item Best Practice
  \item Projection Methods
    \begin{itemize}
    \item Mathematica Implementation
  \item XML for Model Definition and Manipulation
  \item Symbolic Algebra for Code Generation
    \end{itemize}
  \item Anisotropic Grid Smolyak
    \begin{itemize}
    \item Mathematica Implementation
  \item XML for Model Definition and Manipulation
  \item Symbolic Algebra for Code Generation
    \end{itemize}
  \item Future Directions
  \end{itemize}
\end{frame}

%\section{\dsgecg\  Objectives and Components}

\subsection{Objectives}

\begin{frame}
  \frametitle{Objectives}  

{%\small
\begin{itemize}
\item To facilitate  
the production of  portable, interoperable, efficient, 
 reliable and compilable code  for estimating,  
simulating,  forecasting and  policy analysis with
DSGE models.
  \begin{itemize}
  \item Apply modern software development tools and techniques
  \item Promote innovation/specialization and collaboration 
  \item Automate error prone tasks
  \item Promote the distribution of tests and examples
  \end{itemize}
\end{itemize}
}
\end{frame}


\begin{frame}
  \frametitle{Outline}
  \begin{itemize}
  \item Generic Projection ala Judd
  \item An Implementation  and its components

  \item gitHub and distribution/updating
  \item Possible extensions

  \item Smolyak
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Projection Method Tool Implementation Strategy}

\begin{itemize}
\item We investigated adapting existing code for solving the problem.
  \begin{itemize}
\item FORTRAN code from Judd 
\item  Matlab code from Gapen and Cosimano. 
\item We found that the code was very useful for benchmarking and validation but \item difficult to modify to solve our particular problem.
\end{itemize}
  \end{itemize}

\begin{itemize}
\item We undertook developing generic Java code with the expectation that 
  \begin{itemize}
  \item 
it would be faster than Matlab,
\item easy to interface with Matlab and
\item  comparable to ``C''/Fortran in performance.
\item it would work on Linux and Windows machines
\item we could use one of many free development tools 
for debugging and documenting the code.
  \end{itemize}
\end{itemize}



\end{frame}

  


\begin{frame}
  \frametitle{Components of a Generic Projection Tool}
  \begin{itemize}
  \item Canonical Representation\cite{judd98}\


\begin{equation*}
  \mathcal{N}(f)=0\text{ where }\mathcal{N}:B_{1}\rightarrow B_{2}\text{ and }%
  f:D\subset R^{n}\rightarrow R^{m}
\end{equation*}%

\vspace{1cm}

\begin{enumerate}
\item Choose a basis and a norm over $B_{1}$, and a basis and an inner
  product over $B_{2}.$

\item Choose a degree of approximation, $n$, to define $\hat{f}\equiv
  \sum_{i=1}^{n}a_{i}\varphi _{i}(x).$

\item Construct approximation $\hat{\mathcal{N}}$ to define
  $R(x;a)\equiv \hat{\mathcal{N}}(\hat{f}(\cdot ;a))(x).$

\item Compute $\parallel R(\cdot ;a)\parallel $ or choose $p_{i}$ and
  compute $P_{i}(a)\equiv <R(\cdot ;a),p_{i}(\cdot )>$.

\item Find $a\ni P(a)=0 $, (Collocation) or $\arg\min <R(\cdot
  ;a),p_{i}(\cdot )>$ (Gallerkin or Method of Moments)


\item Verify the quality of the solution.
\end{enumerate}
\end{itemize}

\end{frame}
\begin{frame}

\frametitle{Step 1: Choose basis, norms and inner products }

\begin{itemize}
\item Only interested in bounded values of the state variables
\item Outer product of closed finite one dimensional intervals
  $B_{1}=[l_{x_{1}},u_{x_{1}}]\otimes \ldots \otimes \lbrack
  l_{x_{n}},u_{x_{n}}]$.
  \begin{itemize}
  \item two state variables $s_t =
    \begin{bmatrix}
      \Delta_{t-1}, A_{t}
    \end{bmatrix}^T$ $\Delta _{t-1} \in [1,3], \epsilon_t \in [-1,1]$.
  \item 10 non state variables
    \begin{gather*}
      \Pi(s_{t}), C(s_{t}), F(s_{t}), H(s_{t}), S(s_{t}),
      \varphi_1(s_{t}),\varphi_{2}(s_{t}),\varphi_{3}(s_{t}),
      \varphi_{4}(s_{t}),\varphi_5(s_{t})
    \end{gather*}
  \item Satisfy \hyperref[eqns]{12 equations} $B_2=R^{12}$
  \item Variables dated t+1 require function compositions
  \end{itemize}
\item Chebyshev polynomials for basis functions.
  % \item close to the polynomial of best approximation to a
  %   continuous function under the maximum norm.
\item Chebyshev polynomials are only defined on the interval $[-1,1]$,
  linearly interpolated each finite range to that interval.
\end{itemize}

\end{frame}
\begin{frame}

\frametitle{Some Chebyshev Polynomial Implementation Details}
\begin{itemize}
\item Implemented in Java
  \begin{itemize}
  \item Faster than Matlab
  \item Easily accessible from Matlab (or Mathematica)
  \item Eclipse/Wolfram Workbench provide inexpensive robust IDE
  \end{itemize}
\item Code monitors whether the interval ranges are violated
\item Code can compute the derivatives of the Chebyshev polynomial
\item Code can compute the derivative of the approximated state or non
  state polynomial functions with respect to other approximated state
  variables $L^\prime(\Delta_t), M^\prime(\Delta_t)$
\end{itemize}



\end{frame}
\begin{frame}

\frametitle{Step 2: Choose a degree of approximation }
\begin{itemize}
\item Both state and non-state variables will be linear combinations
  of polynomials in $s_t=
  \begin{bmatrix}
    \Delta_{t-1}\\ \epsilon
  \end{bmatrix}$
  \begin{itemize}
  \item Most results presented here we set $\epsilon_t=0$ and used a
    25th degree polynomial in $\Delta_{t-1}$
  \item With non-zero shocks, experiments varied $\Delta_{t-1}$ 6 to
    10th degree and and $\epsilon_t$ 3rd to 6th degree.
  \end{itemize}
\item We used Chebyshev points for our collocation points.  Thus the
  order of approximation determines the size of the nonlinear system
  we must solve.
\end{itemize}

\end{frame}
\begin{frame}

\frametitle{Step 3: Construct approximation}
\begin{itemize}
\item The state and non-state variables at time $t$ are a weighted sum
  of the basis functions.
  \begin{gather*}
    \mathcal{W} \Phi
  \end{gather*}
  where $\Phi$ is a matrix of values determined by the outer product
  of polynomials evaluated at the Chebyshev Nodes.
\item Variables dated t+1 require function compositions
\item When shocks are non zero t+1 variables require integration.  We
  employ 10th order Gauss-Hermite interpolation
\item We evaluate the \hyperref[eqns]{system of equations} at at each
  of the Chebyshev nodes.
\item This evaluation process produces a vector of values and a matrix
  of derivatives (with respect ot the weights) for use in Newton's
  method
\item For any given model, we use Mathematica code to generate Java
  Code that invokes the projection method routines
\end{itemize}



\end{frame}
\begin{frame}

\frametitle{Steps 4 and 5: Solve Collocation Equations}
\begin{itemize}
\item Given an initial guess for polynomial weights, we use Newton's
  method with analytic derivatives to solve the system of collocation
  equations.
\item Solving this nonlinear system is by far the most difficult task
  to accomplish reliably.
  \begin{itemize}
  \item There is no guarantee that the current approximation will
    generate values for the time-$t$ state variables that lie in
    $B_{1}$
  \item consequently, the Chebyshev polynomials variables may be
    applied to values outside their range of definition.
  \item This may not prove to be a problem so long as the Newton step
    converges to a solution where the values are within the range of
    definition,
  \item the intermediate polynomial functions used %
    {in conjunction} with the model equations will produce other
    numerical errors (e.g. the log of a negative number).
  \item {Problems with $\beta$ and $\phi$}
    \begin{itemize}
    \item Small unrealistic $\beta$ easier to solve
    \item $\phi=0$ solution not of interest but easier to solve
    \end{itemize}
  \end{itemize}
\end{itemize}



\end{frame}
\begin{frame}
\frametitle{Projection Method Robust Solution Strategies}
\begin{itemize}
\item Nonlinear equation systems are notoriously difficult to solve
\item Good initial guesses difficult to conjure
\item Employing a ``homotopy'' iterative scheme works well for
  reliably improving on initial guesses
\item A four phase solution strategies proved particularly useful
  \begin{itemize}
  \item Begin with an easy version of the problem -- zeroth order,
    ``easy'' parameter settings, small range for Chebyshev polynomials
  \item incrementally search along a linear path from an ``easy'' set
    of parameters to the ``target'' set of parameters
  \item Increase order of polynomial holding polynomial range constant
  \item Increase range of polynomial
  \end{itemize}
\item Code can automatically apply these strategies, but human
  intervention often necessary
\end{itemize}




% For the problem at hand, we have found that---to obtain convergence
% for a given degree of approximation---it is important to start with
% a small range of values of $\Delta _{t-1}$ in the definition of the
% Chebyshev polynomials and then to gradually {extend} the range. \ %
% {We have written the code to make }it easy to adjust the variable
% interpolation range. For a given set of parameters and a given
% degree of approximation, we systematically adjust the range from
% small to large.


%\end{frame}
%\begin{frame}
% \frametitle{Overloaded Operators for Differentiation}
% \begin{itemize}
% \item Solving linear system hardest part
% \item Getting initial guess hard
% \item Zeroth order polynomials
% \item Increase Each dimension
% \item Some parameters sets easier to solve
% \item Homotopy


%   \begin{itemize}
%   \item For the problem at hand, we have found that---to obtain
%     convergence for a given degree of approximation---it is
%     important to start with a small range of values of $\Delta
%     _{t-1}$ in the definition of the Chebyshev polynomials and then
%     to gradually {extend} the range. \ %
%   \item {We have written the code to make }it easy to adjust the
%     variable interpolation range. For a given set of parameters and
%     a given degree of approximation, we systematically adjust the
%     range from small to large.
%   \end{itemize}
% \end{itemize}



\end{frame}
\begin{frame}

\frametitle{Step 6: Verify the Quality of Solution}

\begin{itemize}
\item For $\Phi =0$ analytic solution with no shocks:
  \begin{itemize}
  \item We have 25th order polynomial
  \item decision rules accurate to machine precision
  \item even 10th degree polynomial very close
  \end{itemize}
\item For $\Phi \ne 0$ we used equation %\ref{eq:copt4} to asses
  accuracy.
  \begin{itemize}
  \item We computed a measure of relative error of 0.02\% in the value
    of $\Delta_{t}$.
  \end{itemize}
\end{itemize}












\end{frame}
%\begin{frame}

% \frametitle{mathematica front end}
% \begin{itemize}
% \item example model input files
% \item what they generate
% \item interface to java routines
% \item root
% \item projmodel
% \item someresults
% \item Mathematica generate relevant program files
% \end{itemize}



%\end{frame}
%\begin{frame}





% \frametitle{Java}

% \begin{itemize}
% \item Object oriented
% \item Poly interface hide complexity plug and play
% \item Compare Judd
% \item Compare Cosimano
% \item Times for Our model
% \item Mathematica Workbench
% \end{itemize}








%\end{frame}
%\begin{frame}

% \frametitle{Soltions near points of interest highly linear}
% \begin{itemize}
% \item Pictures near
% \item pictures away
% \end{itemize}


%\end{frame}



\begin{frame}
  \frametitle{projectionmethodtools workflow}
  \begin{itemize}
  \item model equation specification generate model creates java class
  \item few constraints of java class  one lag one lead two shocks (list of functions)special derivatives
  \item projection method chearacteristics specification, ranges
    \item includes some homotopy methods
    \item expand from center
    \item clever newton step
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{more projection method}
  \begin{itemize}
  \item class organization importent components relate to judd taxonomy
  \item developing an explicit API via javadocs
    \begin{itemize}
    \item grid spec
    \item eqvaldrv
    \item strategy
    \item best practice patterns
    \end{itemize}
  \item mma generates a java program
  \item grid chebyshev polynomials and chebysheve extrema
  \item grid does linear map to -1,1
  \item each variable gets a polynomial  ( not limiting )
equations
  \end{itemize}
\end{frame}


\subsection{Anisotropic Grid Smolyak}


\begin{frame}
  \frametitle{Anisotropic Grid Smolyak}
{\small
\cite{Judd2013} describes a technique for improving the performance of
the Smolyak method.
\begin{itemize}
\item {\bf sparseGridEvalPolysAtPts}[numVars\_Integer,approxLevel\_Integer,
ptGenerator\_Function,polyGenerator\_Function] 
\item {\bf sparseGridEvalPolysAtPts}[listOfApproxLevels\_?ArrayQ,
ptGenerator\_Function,polyGenerator\_Function] 
\item {\bf chebyshevPolyGenerator}[numPts\_Integer] generates chebyshev polynomials of the first kind with xx as the variable"
\item {\bf chebyshevPtGenerator}
\end{itemize}
}
\end{frame}

% \begin{frame}
%   \frametitle{Smolyak }
%   \begin{itemize}
%   \item \item discontinuous smolyak
% \item Other generators
%   \begin{itemize}
%   \item Isotropic 
%   \item Anisotropic
%   \end{itemize}
%   \end{itemize}
% \end{frame}

\begin{frame}
  \frametitle{Outputs}
  \begin{itemize}
  \item $\hat{f}(x;b)=\sum_{n=1}^M b_n \Psi_n(\chi)$
  \item $
    \begin{bmatrix}
      f(\chi_1)\\ \cdots \\       f(\chi_M)
    \end{bmatrix}=
    % \begin{bmatrix}
    %   \hat{f}(\chi_1)\\ \cdots \\       \hat{f}(\chi_M)
    % \end{bmatrix}=
      \begin{bmatrix}
        \Psi_1(\chi_1) &\cdots &        \Psi_M(\chi_1)\\
\vdots&\ddots&\cdots\\
        \Psi_1(\chi_1)& \cdots   &      \Psi_M(\chi_1)
      \end{bmatrix}
      \begin{bmatrix}
        b_1\\ \vdots \\ b_m
      \end{bmatrix}= \mathcal{B} b
$
  \item The tuples of Smolyak grid points $\{\chi_1, \ldots , \chi_M\}$
  \item The vector of polynomial basis functions $\{\Psi_1, \ldots , \Psi_M\}$ (alternatively as calls to chebyshev library)
  \item The polynomials evaluated at the Smolyak grid points $\mathcal{B}$
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{smolyak}

  \begin{itemize}
  \item smolyak in mathematica
  \item matrix for mapping values into weights
  \item symbolic albebra
  \item can generalize the point generator uses chebyshev zeroes (extrema?)
  \item uni dimensional point generator requirements
  \item savings in the dimensionality of points
  \item accuracy
  \end{itemize}
\end{frame}



\begin{frame}
  \frametitle{To Include}
  \begin{itemize}
  \item ProjectionMethodTools
    \begin{itemize}
    \item Downloadable from git  How to
    \item mathematica generates a eqvaldrv object from easy to enter model eqns
    \item splits out components that require integration
    \item one lag one lead
    \item derivatives with respect to other variables that are represented by projecition polynomials
    \item state vs non state variables
    \item two shocks
    \item use for validation
    \item has an error at the moment in computation of derivatives
    \item overloaded operations pointwise for derivatives most common operations
    \item includes newton method
    \end{itemize}

  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{more stuff}
  \begin{itemize}
\item $y_{t}=f(x_{t-1},\epsilon_t),z_t=y_{t+1}$
  \item can model expectations
  \item just generates equations for computing eqvaldrv for the specified
  \item java program good for checking
  \item speed not too bad
  \end{itemize}
\end{frame}



\begin{frame}
  \frametitle{git}
  \begin{itemize}
  \item git
    \begin{itemize}
    \item version control essentials
    \item concepts and workflow
    \item commits
    \item clone
    \item pull and push
    \item branches
    \end{itemize}
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{for the future}
  \begin{itemize}
  \item more generators
  \item model specification code
  \item incorporation in to projectionmethod tools
  \end{itemize}
\end{frame}


\subsection{Components}
\begin{frame}
  \frametitle{Components}  

{\small
  \begin{itemize}
\item Symbolic algebra tools for manipulating model equations
 -- currently {\bf \mma}  ({\bf sympy} for the future)
\item {\bf XML} for specifying model equations and 
for specifying operations on the model
\item The {\bf antlr} parser generator for mapping alternative 
model specification languages into  XML
\item Explicit  API's for generated code
\item {\bf gitHub} for version control and code distribution
  \end{itemize}

}
\end{frame}



\begin{frame}
  \frametitle{Targets}
  \begin{columns}
    \begin{column}{.5\linewidth}
      

  \begin{itemize}
\item Target Languages
    \begin{itemize}
    \item Dynare
    \item Matlab
    \item Fortran
    \item C
    \item \LaTeX
    \end{itemize}
\item Target architectures
  \begin{itemize}
\item Ubiquitous multicore stand-alone machines
  \item Increasingly available networked multicore machines
  \item GPUs
  \end{itemize}


  \end{itemize}
\end{column}
    \begin{column}{.5\linewidth}

      \begin{itemize}
      \item Directory Structure
      \end{itemize}


\dirtree{%
.1 theRootDir.
.2 code.
.2 docs.
.2 tests.
.2 examples.
}



\end{column}

  \end{columns}


\end{frame}

% \begin{frame}
%   \frametitle{Other Benefits}
%   \begin{itemize}
%   \item reproducible results
%   \item design to evolve ( expect breakage )
%   \item Promotes Testing
%   \item Eliminates Error Prone Tasks
%   \item Division of labor and synergy  github
%   \end{itemize}
% \end{frame}




\section{XML for  Model Definition and Manipulation}

\begin{frame}
  \frametitle{Star Concept}
  \begin{itemize}
 \item Parse from language into an Intermediate Model Representation (IMR)
 -- ``Abstract Syntax Tree'' 
  \item Post process from IMR to other useful forms
  \item Star concept --  multiple languages into and out of IMR
    \begin{itemize}
    \item \LaTeX outpput
    \item Language translation
    \item Code generation
    \end{itemize}

  \item Uses XML Schema, XSL tools
  \end{itemize}

\end{frame}
\section{Examples}


\begin{frame}
  \frametitle{gitHub Links for DSGECodeGen Software}
  

  \begin{description}
  \item[ \cite{Judd2013} Package mathSmolyak`] \href{https://github.com/es335mathwiz/AccelerateAMA.git}{https://github.com/es335mathwiz/AccelerateAMA.git}
\end{description}

\end{frame}

\begin{frame}

\frametitle{Hybrid Functions}

\begin{itemize}
\item Combine Block Pulse Functions with Orthogonal Polynomials
\item Inherit Orthogonality
\item Useful for characterizing piecewise continuous functions
  \begin{gather*}
    b_{nm}(x), n=1,2,\ldots,N,m=0,1,\ldots,M-1,\,\, x \in (x_{min},x_{max})\\
    b_{nm}(x)=
    \begin{cases}
      P_m(\frac{2N}{x_W}(x-x_{min})- 2n+1)&
      \frac{n-1}{N}x_W\le x-x_{min}<\frac{n}{N}x_W\\
      0&otherwise
    \end{cases}\intertext{ where }
    x_W=x_{max}-x_{min}
  \end{gather*}
\item Slight Generalization of \cite{marzban03}
\item Block Pulse Functions
\item DMISER
\end{itemize}


\end{frame}
\begin{frame}

\frametitle{Hybrid Functions}

\begin{figure}
  \centering
   \includegraphics{bpfGraph.pdf}
  \caption{Hybrid Functions of Block-Pulse and Legendre Polynomials
    $b_{ij}(6,4)$}
  \label{fig:bgraph}
\end{figure}

\end{frame}
\begin{frame}
  \frametitle{CodeGen}
Generates code for 

  \begin{itemize}
  \item Evaluating a user function at nodes
  \item Solving the linear system to get weights
  \item Evaluating function with computed weights
  \end{itemize}

 Uses \mma\   and  its Format and Optimize packages

\end{frame}





\begin{frame}
  \frametitle{sympy}
  
  \begin{itemize}
  \item Summer Intern Implementing AMA in python using sympy
  \item All necessary components there
    \begin{itemize}
    \item QRDecomposition
    \item LUDecomposition
    \item Eigenvalue and Eigenvector  NullSpace
    \end{itemize}
  \item Mathematica more comprehensive Matrix manipulation
  \item Expect same bottle neck
  \end{itemize}
\end{frame}



\section{Future Directions}

\begin{frame}
  \frametitle{Future Directions}
  \begin{itemize}
  \item Employing sympy
 \item Log linearization 
\item Occassionally binding constraints
\item Collaboration %Michelle, Sabastein, Pablo, Chris
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Bibliography}
  \bibliographystyle{authordate4}
\bibliography{anderson,files}

\end{frame}


% \begin{frame}{MIT Hints}
%   \href{http://web.mit.edu/rsi/www/pdfs/beamer-tutorial.pdf}{mit beamer slide how to}
% \end{frame}
% \begin{frame}

%   \frametitle{Things to do}
%   \begin{itemize}
% \item other good Mma over the years? check github
% \item perturbation  rmat then balance or multicore
% \item power series for impulse response function
% \item symbollic function evaluated at grid points?
% \item GSM code /msu/scratch/m1gsa00/learnProjection/proto/authoritative/newGsmCode.mth
% \item<1>{this is overlay}\only<2->{aha}
% \item<2>{what do you know}
% \item<3>{what do you 3}
% \item<5>{what do you 5}
% \end{itemize}
%  \begin{itemize}
%       \item\only<1>{World peace}\only<2->{\sout{World peace}}
%       \item<2-> Peace in our neighbourhood
%     \end{itemize}
% \end{frame}

\begin{frame}
  \frametitle{To Do}
  \begin{itemize}
  \item Problem with Tensors
  \item Smolyak Improvement
  \item Problem with Smolyak
  \item JMMV improvement
  \item Examples
    \begin{itemize}
    \item JMMV
    \item Luca
    \item Experiments at the ZLB
    \item My Formulae
    \end{itemize}
  \item 
  \item Mathematica Implementation
  \item Block Coded Pulse
  \item 
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Whiteboard}
  \begin{description}
  \item[Smolyak gencode multi gens?]
  \item[B $\phi$ F]
  \item[GPU]
  \item[Maple sym alg block coded pulse]
  \item[symb paper calcs to josh]
  \item[modelez to python]
  \item[tests]
  \item[dynare to ama, c python matlab]
  \item[math9 or 10 on linux]
  \item[regularize github]
  \item[undefined ranges?]
  \item[proj method tools examples] 
  \end{description}
\end{frame}

\begin{frame}
  \frametitle{more whiteboard}
  \begin{description}
  \item[smolyak reconcile]
  \item[error calculations]
  \item[components for comparison]
  \item[judd examples]
  \item[model diagnostics sanity checks error messages ]
  \item[print state non state list etc for early feedback]
  \item[java exception output?]
  \item[cnstrns?]
  \item[iteration history $\sigma \rightarrow 0$]
  \item[why only two judd stochastic polys,  Chop $\theta_t$]
  \end{description}
\end{frame}


\begin{frame}
  \frametitle{more more whiteboard}
  \begin{description}
  \item[Mma, linux desktop]
  \item[download works]
  \item[Sandvox]
  \item[MSU sharepoint]
  \item[paperProduction without submodules]

  \item[comparison to vilaverde github]
  \item[git rid of feature branch] 
\end{description}
\end{frame}


\end{document}
