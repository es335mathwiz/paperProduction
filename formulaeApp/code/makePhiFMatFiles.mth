
<<prepNumericAMA.mth

makeMat[srcDir_String,modName_String,targDir_String,opts___]:=
Module[{dm=parseToXMLMTH[srcDir,modName,targDir]},
With[{modEqns=getEqns[FileBaseName[modName]]},
With[{lags=getLags[modEqns],leads=getLeads[modEqns]},
Print["For "<>modName<>" numEq=",Length[modEqns],",leads=",leads,",lags=",lags];
mod=compTimeComponents[srcDir,modName,targDir,Join[{doParamSubs->True},Flatten[{opts}]]];
{modH,modB,modPhi,modF}=mod[[{-2,-7,-6,-5}]];
Export[targDir<>"/"<>FileBaseName[modName]<>".mat",
{
FileBaseName[modName]<>"XXlags"->{{lags}},
FileBaseName[modName]<>"XXleads"->{{leads}},
FileBaseName[modName]<>"XXH"->modH,
FileBaseName[modName]<>"XXB"->modB,
FileBaseName[modName]<>"XXPhi"->modPhi,
FileBaseName[modName]<>"XXF"->modF
},"LabeledData"]]];mod]


(*
allDynareMods=
StringReplace[#,"dynareExamples/"->""]&/@
FileNames["*.mod","dynareExamples"]



res=makeMat["dynareExamples","AltEx1.mod","./resDir",ssInitVals->{1,1,1,1,1,1}];res[[-5]]
res=makeMat["dynareExamples","AssetPricingApproximation.mod","./resDir",ssInitVals->{.0015,100,100,.0015,0}];res[[-5]]
res=makeMat["dynareExamples","BGGViegi.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples","Fig1131.mod","./resDir"];;res[[-5]]
res=makeMat["dynareExamples","Figv3_1161.mod","./resDir"];;res[[-5]]
res=makeMat["dynareExamples","Figv3_1191.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples","firmValue.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples","fs2000.mod","./resDir",ssInitVals->{E^(.003),E^(.003),.85,1,.45,E^(-.003),.19,.86,1.011,6,4,2.25,1.02,.6}](*problems with evals*);res[[-5]]
res=makeMat["dynareExamples","fuhrerMoore.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples","GrowthApproximate.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples","hall1estimateBayes.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples","HSTBayes.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples","ifs1.mod","./resDir",ssInitVals->
{0.010101,0,0.0696621,0.913657,0,.199608,.188,1.158,0.0337,0.0068,-0.076,.2611,0,0.029,1.058,.103,1.137}];res[[-5]](*singularity after ar*)

res=makeMat["dynareExamples","kiyotakiMooreViegi.mod","./resDir"];res[[-5]](*failed after evals*)
res=makeMat["dynareExamples","lesothoViegi.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples", "lubikSchorfheide.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples", "RBCEst.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples", "RBCMonopDet.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples", "RBCMonopJFV.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples", "RBCViegi.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples", "rosenestimateBayes.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples", "simpleNeoViegi.mod","./resDir"];res[[-5]]
res=makeMat["dynareExamples", "TwocountryApprox.mod","./resDir"];res[[-5]](*failed after evals*)(*no leads?*)

problemDynareMods={
"Figv3_1191.mod" trouble finding steady state
fs2000 trouble steady state
hstbayes problem compbphif  singular
ifs1 gmpn_add_nc library
kiyotakimooreviegi b wrong num rows

rosen estimate bayes problems with  array flatten  (4 leads 4 lags )

twocoountryapprox problems with singular


parse problems cesa-bianchi  no graph

SU03  library problem


rbc parse problems
}

makeMat["dynareExamples",#,"./resDir"]&/@Complement[allDynareMods,problemDynareMods]
{ "AltEx1.mod","AssetPricingApproximation.mod", "BGGViegi.mod", 
 "Fig1131.mod", "Figv3_1161.mod", "Figv3_1191.mod", "firmValue.mod", 
 "fs2000.mod", "fuhrerMoore.mod", "GrowthApproximate.mod", 
 "hall1estimateBayes.mod", "hall1estimateML.mod", "HSTBayes.mod", "ifs1.mod", 
 "kiyotakiMooreViegi.mod", "lesothoViegi.mod", "lubikSchorfheide.mod", 
 "RBCEst.mod", "RBCMonopDet.mod", "RBCMonopJFV.mod", "RBCViegi.mod", 
 "rosenestimateBayes.mod", "simpleNeoViegi.mod", "TwocountryApprox.mod"}




*)
(*

check phi f

res=makeMat["dynareExamples","firmValue.mod","./resDir"];
hmat=res[[-2]];
bmat=res[[-7]];
phimat=res[[-6]];
fmat=res[[-5]];
psimat=IdentityMatrix[2];
zpath={{aa},{bb},{cc},{dd}};
xinit={{vv},{dd}}

computeDelXPath[bmat,phimat,fmat,psimat,zpath]
computeXNext[xinit,bmat,phimat,fmat,psimat,zpath]
computeXPath[xinit,1,bmat,phimat,fmat,psimat,zpath]
hmat .Join[xinit, computeXPath[xinit,2,bmat,phimat,fmat,psimat,zpath]]//Expand//Chop
hmat . computeXPath[xinit,3,bmat,phimat,fmat,psimat,zpath]//Expand//Chop




res=makeMat["dynareExamples","firmValue01x02.mod","./resDir"];
hmat=res[[-2]];
bmat=res[[-7,{1,2}]];
phimat=res[[-6]];
fmat=res[[-5]];
psimat=IdentityMatrix[2];
zpath={{aa},{bb},{cc},{dd}};
xinit={{vv},{dd}}

computeDelXPath[bmat,phimat,fmat,psimat,zpath]
computeXNext[xinit,bmat,phimat,fmat,psimat,zpath]
computeXPath[xinit,1,bmat,phimat,fmat,psimat,zpath]
hmat .Join[xinit, computeXPath[xinit,3,bmat,phimat,fmat,psimat,zpath]]//Expand//Chop
hmat .computeXPath[xinit,4,bmat,phimat,fmat,psimat,zpath]//Expand//Chop



res=makeMat["dynareExamples","rosenestimateBayes.mod","./resDir"];
hmat=res[[-2]];
bmat=res[[-7,{1,2,3,4}]];
phimat=res[[-6]];
fmat=res[[-5]];
psimat=IdentityMatrix[4];
zpath={{aa},{bb},{cc},{dd},{aaa},{abb},{acc},{add},{baa},{bbb},{bcc},{bdd},{caa},{cbb},{ccc},{cdd}};
xinit={{vv},{dd},{xx},{ww},{vv1},{dd1},{xx1},{ww1},{vv2},{dd2},{xx2},{ww2},{vv3},{dd3},{xx3},{ww3}}

computeDelXPath[bmat,phimat,fmat,psimat,zpath]
computeXNext[xinit,bmat,phimat,fmat,psimat,zpath]
computeXPath[xinit,1,bmat,phimat,fmat,psimat,zpath]
hmat .Join[xinit, computeXPath[xinit,5,bmat,phimat,fmat,psimat,zpath]]//Expand//Chop
long=Join[xinit,computeXPath[xinit,9,bmat,phimat,fmat,psimat,zpath]//Expand//Chop];

hmat .long[[Range[36]]]//Expand//Chop

linear easy
TimeConstrained[makeMat[#],10]&/@ {"firmValue",  "fuhrerMoore", 
 "hall1estimateBayes"}
linear hard
TimeConstrained[makeMat[#],60]&/@ { 
 "lubikSchorfheide", 
"rosenestimateBayes", "lesothoViegi"};

*)
(*
non linear easy

{"AssetPricingApproximation"}

hard but completes

Fig1131
*)



(*


makeMat[modName_String]:=
Module[{dm=parseToXMLMTH["dynareExamples/",modName,Directory[]<>"/"]},
With[{modEqns=getEqns[modName]},
With[{lags=getLags[modEqns],leads=getLeads[modEqns]},
Print["numEq=",Length[modEqns],",leads=",leads,",lags=",lags];
mod=allPhiF["dynareExamples/",modName,Directory[]<>"/"];
{modH,modB,modPhi,modF}=mod[[{-2,-6,-5,-4}]]/.mod[[-8]];
Export[modName<>".mat",
{
modName<>"XXlags"->{{lags}},
modName<>"XXleads"->{{leads}},
modName<>"XXH"->modH,
modName<>"XXB"->modB,
modName<>"XXPhi"->modPhi,
modName<>"XXF"->modF
},"LabeledData"]]]]



*)
