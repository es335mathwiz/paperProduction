$antlrPath="/msu/res1/Software/functional/rootbeer1/lib/antlr-3.1.3.jar";

$AMAModelPath="../../mathAMA/AMAModel";
$AMAModelXSLPath="../../multiverse/forMultiverse/src/main/xsl/AMAModel2Mma.xsl"
$NumAMAPath="../../mathAMA/NumericAMA/NumericAMA";
$SymAMAPath="../../mathAMA/SymbolicAMA/SymbolicAMA";

PrependTo[$Path,$NumAMAPath];
PrependTo[$Path,$SymAMAPath];
PrependTo[$Path,$AMAModelPath];
Needs["NumericAMA`"];
Needs["AMAModel`"];
AddToClassPath[Directory[]<>"/../../DynareParsers/target/classes"];
AddToClassPath[$antlrPath];
srcDir="";
(*
converts dynare models to xml then xml model to equations for mathematica
creates an AMAModelDefinition
*)

parseToXMLMTH::usage="parseToXMLMTH[srcDir_String,fName_String] parses a dynare model file to xml and then applies xslt to generate a .mth AMAModel file and reads in the .mth file"
AMAModelDefinition::usage="AMAModelDefinition[modName_String] returns {{list of Vars},{list of params with default vals},{list of shocks with default distribution},{{list of eqnNames},{list of eqns}},{list of shock subs}}"

parseToXMLMTH[srcDir_String,fName_String]:=
parseToXMLMTH[srcDir,fName,Directory[]]

parseToXMLMTH[srcDir_String,fName_String,targDir_String]:=
Module[{cmd},
System`$Path=PrependTo[System`$Path,srcDir];
JavaNew["gov.frb.ma.msu.DynareToAMAModel",srcDir<>"/"<>fName,targDir<>"/"<>FileBaseName[fName]<>".xml",FileBaseName[fName],Directory[]<>"/"];
cmd=StringForm[
"java org.apache.xalan.xslt.Process -IN `2`/`1`.xml  -XSL `3` -OUT `2`/`1`.mth",FileBaseName[fName],targDir,$AMAModelXSLPath];
(*Print["here is cmd",cmd,"after"];*)
Run[cmd];
Get[targDir<>"/"<>FileBaseName[fName]<>".mth"];
AMAModelDefinition[FileBaseName[fName]]]




largeLocs[theVals_List]:=
With[{mags=(#>1)&/@Abs[theVals]},Flatten[Position[mags,True]]]


doNullSpace[lilMat_?MatrixQ,eval_]:=
If[eval==={},{},
NullSpace[Transpose[lilMat]-eval*IdentityMatrix[Length[lilMat]]]]

compEigSpace[lilMat_?MatrixQ,evals_List,paramSubs_List] := 
   Join @@ (doNullSpace[lilMat, evals[[#1]]]) &  /@ 
largeLocs[evals//.paramSubs]
toLarge[{},lilCols_List,cols_Integer]:={}

toLarge[lil_?MatrixQ,lilCols_List,cols_Integer]:=
Module[{bigEvecs},
bigEvecs=ConstantArray[0,{Length[lil],cols}];
bigEvecs[[All,lilCols]]=lil;
bigEvecs]


compB[zf_?MatrixQ,{},neq_Integer]:={}

compB[zf_?MatrixQ,evs_?MatrixQ,neq_Integer]:=
With[{qmat=Join[zf,evs]},
With[{qcols=Length[qmat[[1]]],qrows=Length[qmat]},
With[{qr=qmat[[All,qcols-qrows+Range[qrows]]],
ql=qmat[[All,Range[qcols-qrows]]]},
(-Inverse[qr].ql)]]]

obStruct[hmat_?MatrixQ,bigB_?MatrixQ]:=
With[{neq=Length[hmat],lTau=Length[bigB[[1]]],lTheta=Length[bigB]},
With[{hMinus=hmat[[All,Range[lTau+neq]]],
hPlus=hmat[[All,lTau+neq+Range[lTheta]]]},
hMinus+blockMatrix[{{zeroMatrix[neq],hPlus . bigB}}]]]


getLags[eqns_List] := With[{}, 
    With[{lgld = Union[Cases[eqns, (xx_)[yy:t + (zz_.)] -> zz, Infinity]]}, 
     -Min[lgld]]]
getLeads[eqns_List] := With[{}, 
    With[{lgld = Union[Cases[eqns, (xx_)[yy:t + (zz_.)] -> zz, Infinity]]}, 
     Max[lgld]]]

getEqns[modName_String]:=
With[{modDef=AMAModelDefinition[FileBaseName[modName]]},
If[Length[modDef]>=5,modDef[[5,2]],{}]]

getShocksSubs[modName_String] := 
With[{modDef=AMAModelDefinition[FileBaseName[modName]]},
modDef[[-2]]]
getShocksZeroSubs[modName_String] := 
With[{modDef=AMAModelDefinition[FileBaseName[modName]]},
(modDef[[-2]]/.eps[_][t]->0)]

(*
linear mods
{"firmValue",  "fuhrerMoore", 
 "hall1estimateBayes", "hall1estimateML", "lesothoViegi", "lubikSchorfheide", 
"rosenestimateBayes", "rosenestimateML"};

*)
compTimeComponents::usage="compTimeComponents[theDir_String,modName_String,targDir_String,opts___] "<>"{parseTime,hmatTime,arTime,amatTime,lilTime,evalsTime,lilevecsTime,evecsTime,bmatTime,sTime,paramSubs,eqns,bmat,phiMat,fMat,theS,solveSoln,hmat,vars}"


compTimeComponents[theDir_String,modName_String,targDir_String,opts___]:=
Module[{parseTime,vars,ig,params,eqns,notSubs,paramSubs,
hmatTime,hmat,
arTime,zf,hf,
amatTime,amat,
lilTime,lilMat,cols,
evalsTime,evals,
lilevecsTime,lilevecs,
evecsTime,evecs,
bmatTime,bmat,
sTime,theS},
{parseTime,{vars,ig,params,ig,{ig,eqns},notSubs,ig}}=
Timing[parseToXMLMTH[theDir,modName,targDir]];
paramSubs=#[[1]]->#[[2]]&/@Rationalize[params,1/100000];
earlySubs=If[MemberQ[Flatten[{opts}],doParamSubs],paramSubs,{}];
(*{solveTime,solveSoln}=Timing[trySolveSS[(eqns//.earlySubs)/.getShocksZeroSubs[FileBaseName[modName]],vars]];*)
{fRootTime,fRootSoln}=Timing[makeSomeSSSubs[FileBaseName[modName]]];
{hmatTime,hmat}=Timing[N[equationsToMatrix[(eqns//.earlySubs)/.fRootSoln,vars]/.makeSSValSubs[vars]]/.fRootSoln];
{arTime,{zf, hf}} = Timing[symbolicAR[hmat]];Print["done ar"];
{amatTime,amat} = Timing[symbolicTransitionMatrix[hf]];
{lilTime,{lilMat,cols}}=
Timing[symbolicEliminateInessentialLags[{amat,Range[Length[amat]]}]];Print["done inessential"];
{more,lilMat}=Timing[FullSimplify[lilMat,TimeConstraint->$tConst]];lilTime=lilTime+more;
{evalsTime,evals}= Timing[TimeConstrained[Eigenvalues[Transpose[lilMat]],$tConst]];Print["done evals"];
{lilevecsTime,lilevecs}=Timing[TimeConstrained[compEigSpace[lilMat,evals,Join[paramSubs,fRootSoln]],$tConst]];
{evecsTime,evecs}=Timing[toLarge[lilevecs,cols,Length[zf[[1]]]]];
Print["compute bmat phimat fmat"];
qmat=Join[zf,evecs];
{bmatTime,{bmat,phiMat,fMat}}=Timing[symbolicComputeBPhiF[hmat,qmat]];
Print["gen smat"];
{sTime,theS}=Timing[obStruct[hmat,bmat]];
{parseTime,hmatTime,arTime,amatTime,lilTime,evalsTime,lilevecsTime,evecsTime,bmatTime,sTime,paramSubs,eqns,bmat,phiMat,fMat,theS,fRootSoln,hmat,vars}
]





makeSSValSubs[vars_List]:=#[t_]->ToExpression[ToString[#]<>"SSVal"]&/@vars;

makeSomeSSSubs[name_String]:=
With[{ssEqns=makeSubbedEqns[name],
try=makeTry[name]},
FindRoot @@ {ssEqns,try}]

makeSubbedEqns[name_String]:=
With[{eqns=AMAModelDefinition[name][[5,2]],
subs=Join[makeParamSubs[name],makeShockSubs[name]]},
(eqns//.subs)/.ssValSubs]



makeParamSubs[name_String]:=With[
{params=AMAModelDefinition[name][[3]]},
#[[1]]->#[[2]]&/@params]

makeShockSubs[name_String]:=With[
{shks=AMAModelDefinition[name][[-2]]},
#[[1]]->0&/@shks]


ssValSubs=(xx_)[t + (_.)] :> ToExpression[ToString[xx]<>"SSVal"]


makeTry[name_String,opts___]:=
With[{vars=AMAModelDefinition[name][[1]]},
If[Length[Flatten[{opts}]]>0.
Transpose[{ToExpression[ToString[#]<>"SSVal"]&/@vars,Flatten[{opts}]}],
{ToExpression[ToString[#]<>"SSVal"],Random[]}&/@vars]]



trySolveSS[eqns_List,vars_List]:=
Module[{},
ssEqns=eqns//.ssSubs;
someSSSubs=TimeConstrained[Solve[Thread[ssEqns==0],vars],$tConst];
If[FreeQ[someSSSubs,Solve],(someSSSubs/.
(#->ToExpression[ToString[#]<>"SSVal"]&/@vars))[[1]],{}
]]


ssSubs=xx_[t+_.]:>xx;




$tConst=20










