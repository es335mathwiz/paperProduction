$antlrPath="/msu/res1/Software/mavenRepositories/tryRep/org/antlr/antlr/3.1.3/antlr-3.1.3.jar"

$AMAModelPath="../../mathAMA/AMAModel";
$AMAModelXSLPath="../../multiverse/forMultiverse/src/main/xsl/AMAModel2Mma.xsl"
$NumAMAPath="../../mathAMA/NumericAMA/NumericAMA";
$SymAMAPath="../../mathAMA/SymbolicAMA/SymbolicAMA";

PrependTo[$Path,$NumAMAPath];
PrependTo[$Path,$SymAMAPath];
PrependTo[$Path,$AMAModelPath];
Needs["NumericAMA`"];
Needs["AMAModel`"];
AddToClassPath[Directory[]<>"/../../DynareParsers/target/classes"];
AddToClassPath[$antlrPath];
preDo="";
(*
converts dynare models to xml then xml model to equations for mathematica
creates an AMAModelDefinition
*)

doMod[preDo_String,fName_String]:=
doMod[preDo,fName,Directory[]<>"/"]

doMod[preDo_String,fName_String,targDir_String]:=
Module[{cmd},
System`$Path=PrependTo[System`$Path,preDo];
JavaNew["gov.frb.ma.msu.DynareToAMAModel",preDo<>fName<>".mod",targDir<>fName<>".xml",fName,Directory[]<>"/"];
cmd=StringForm[
"java org.apache.xalan.xslt.Process -IN `3``2`.xml  -XSL `4` -OUT `3``2`.mth",preDo,fName,targDir,$AMAModelXSLPath];
(*Print["here is cmd",cmd,"after"];*)
Run[cmd];
Get[fName<>".mth"];
AMAModelDefinition[fName]]



allLinear[theDir_String,modName_String,targDir_String]:=
Module[{parseTime,vars,ig,params,eqns,notSubs,paramSubs,
hmatTime,hmat,
arTime,zf,hf,
amatTime,amat,
lilTime,lilMat,cols,
evalsTime,evals,
lilevecsTime,lilevecs,
evecsTime,evecs,
bmatTime,bmat,
sTime,theS},
Print["parsing " <>modName];
{parseTime,{vars,ig,params,ig,{ig,eqns},notSubs,ig}}=
Timing[doMod[theDir,modName,targDir]];
paramSubs=#[[1]]->#[[2]]&/@params;
Print["gen hmat"];
{hmatTime,hmat}=Timing[equationsToMatrix[eqns,vars]];
Print["gen symbolicAR"];
{arTime,{zf, hf}} = Timing[symbolicAR[hmat]];
Print["gen amat"];
{amatTime,amat} = Timing[symbolicTransitionMatrix[hf]];
Print["shrink hmat"];
{lilTime,{lilMat,cols}}=
Timing[symbolicEliminateInessentialLags[{amat,Range[Length[amat]]}]];
Print["gen eigenvalues"];
{evalsTime,evals}= Timing[Eigenvalues[Transpose[lilMat]]];
Print["gen evecs"];
{lilevecsTime,lilevecs}=Timing[compEigSpace[lilMat,evals,paramSubs]];
{evecsTime,evecs}=Timing[toLarge[lilevecs,cols,Length[zf[[1]]]]];
Print["compute bmat"];
{bmatTime,bmat}=Timing[compB[zf,evecs,Length[hmat]]];
Print["gen smat"];
{sTime,theS}=Timing[obStruct[hmat,bmat]];
{parseTime,hmatTime,arTime,amatTime,lilTime,evalsTime,lilevecsTime,evecsTime,bmatTime,sTime,paramSubs,eqns,bmat,theS,hmat,vars}
]

allPhiF[theDir_String,modName_String,targDir_String]:=
Module[{parseTime,vars,ig,params,eqns,notSubs,paramSubs,
hmatTime,hmat,qmat,phiMat,fMat,
arTime,zf,hf,
amatTime,amat,
lilTime,lilMat,cols,
evalsTime,evals,
lilevecsTime,lilevecs,
evecsTime,evecs,
bmatTime,bmat,
sTime,theS},
Print["parsing " <>modName];
{parseTime,{vars,ig,params,ig,{ig,eqns},notSubs,ig}}=
Timing[doMod[theDir,modName,targDir]];
paramSubs=#[[1]]->#[[2]]&/@params;
Print["gen hmat"];
{hmatTime,hmat}=Timing[equationsToMatrix[eqns,vars]];
Print["gen symbolicAR"];
{arTime,{zf, hf}} = Timing[symbolicAR[hmat]];
Print["gen amat"];
{amatTime,amat} = Timing[symbolicTransitionMatrix[hf]];
Print["shrink hmat"];
{lilTime,{lilMat,cols}}=
Timing[symbolicEliminateInessentialLags[{amat,Range[Length[amat]]}]];
Print["gen eigenvalues"];
{evalsTime,evals}= Timing[Eigenvalues[Transpose[lilMat]]];
Print["gen evecs"];
{lilevecsTime,lilevecs}=Timing[compEigSpace[lilMat,evals,paramSubs]];
{evecsTime,evecs}=Timing[toLarge[lilevecs,cols,Length[zf[[1]]]]];
Print["compute bmat phimat fmat"];
qmat=Join[zf,evecs];
{bmatTime,{bmat,phiMat,fMat}}=Timing[symbolicComputeBPhiF[hmat,qmat]];
Print["gen smat"];
{sTime,theS}=Timing[obStruct[hmat,bmat]];
{parseTime,hmatTime,arTime,amatTime,lilTime,evalsTime,lilevecsTime,evecsTime,bmatTime,sTime,paramSubs,eqns,bmat,phiMat,fMat,theS,hmat,vars}
]


largeLocs[theVals_List]:=
With[{mags=(#>1)&/@Abs[theVals]},Flatten[Position[mags,True]]]


doNullSpace[lilMat_?MatrixQ,eval_]:=
If[eval==={},{},
NullSpace[Transpose[lilMat]-eval*IdentityMatrix[Length[lilMat]]]]

compEigSpace[lilMat_?MatrixQ,evals_List,paramSubs_List] := 
   Join @@ (doNullSpace[lilMat, evals[[#1]]]) &  /@ 
largeLocs[evals//.paramSubs]
toLarge[{},lilCols_List,cols_Integer]:={}

toLarge[lil_?MatrixQ,lilCols_List,cols_Integer]:=
Module[{bigEvecs},
bigEvecs=ConstantArray[0,{Length[lil],cols}];
bigEvecs[[All,lilCols]]=lil;
bigEvecs]


compB[zf_?MatrixQ,{},neq_Integer]:={}

compB[zf_?MatrixQ,evs_?MatrixQ,neq_Integer]:=
With[{qmat=Join[zf,evs]},
With[{qcols=Length[qmat[[1]]],qrows=Length[qmat]},
With[{qr=qmat[[All,qcols-qrows+Range[qrows]]],
ql=qmat[[All,Range[qcols-qrows]]]},
(-Inverse[qr].ql)]]]

obStruct[hmat_?MatrixQ,bigB_?MatrixQ]:=
With[{neq=Length[hmat],lTau=Length[bigB[[1]]],lTheta=Length[bigB]},
With[{hMinus=hmat[[All,Range[lTau+neq]]],
hPlus=hmat[[All,lTau+neq+Range[lTheta]]]},
hMinus+blockMatrix[{{zeroMatrix[neq],hPlus . bigB}}]]]


getLags[eqns_List] := With[{}, 
    With[{lgld = Union[Cases[eqns, (xx_)[yy:t + (zz_.)] -> zz, Infinity]]}, 
     -Min[lgld]]]
getLeads[eqns_List] := With[{}, 
    With[{lgld = Union[Cases[eqns, (xx_)[yy:t + (zz_.)] -> zz, Infinity]]}, 
     Max[lgld]]]

getEqns[modName_String]:=
With[{modDef=AMAModelDefinition[modName]},
If[Length[modDef]>=5,modDef[[5,2]],{}]]

(*
linear mods
{"firmValue",  "fuhrerMoore", 
 "hall1estimateBayes", "hall1estimateML", "lesothoViegi", "lubikSchorfheide", 
"rosenestimateBayes", "rosenestimateML"};

*)


allNonLinear[theDir_String,modName_String,targDir_String]:=
Module[{parseTime,vars,ig,params,eqns,notSubs,paramSubs,
hmatTime,hmat,
arTime,zf,hf,
amatTime,amat,
lilTime,lilMat,cols,
evalsTime,evals,
lilevecsTime,lilevecs,
evecsTime,evecs,
bmatTime,bmat,
sTime,theS},
{parseTime,{vars,ig,params,ig,{ig,eqns},notSubs,ig}}=
Timing[doMod[theDir,modName,targDir]];
paramSubs=#[[1]]->#[[2]]&/@params;
{solveTime,solveSoln}=Timing[trySolveSS[eqns,vars]];
{fRootTime,fRootSoln}=Timing[makeSomeSSSubs[modName]];
{hmatTime,hmat}=Timing[equationsToMatrix[eqns,vars]/.makeSSValSubs[vars]];
{arTime,{zf, hf}} = Timing[symbolicAR[hmat]];Print["done ar"];
{amatTime,amat} = Timing[symbolicTransitionMatrix[hf]];
{lilTime,{lilMat,cols}}=
Timing[symbolicEliminateInessentialLags[{amat,Range[Length[amat]]}]];Print["done inessential"];
{more,lilMat}=Timing[FullSimplify[lilMat,TimeConstraint->$tConst]];lilTime=lilTime+more;
{evalsTime,evals}= Timing[TimeConstrained[Eigenvalues[Transpose[lilMat]],$tConst]];Print["done evals"];
{lilevecsTime,lilevecs}=Timing[TimeConstrained[compEigSpace[lilMat,evals,Join[paramSubs,fRootSoln]],$tConst]];
{evecsTime,evecs}=Timing[toLarge[lilevecs,cols,Length[zf[[1]]]]];
{bmatTime,bmat}=Timing[compB[zf,evecs,Length[hmat]]];
{sTime,theS}=Timing[obStruct[hmat,bmat]];
{parseTime,hmatTime,arTime,amatTime,lilTime,evalsTime,lilevecsTime,evecsTime,bmatTime,sTime,solveTime,fRootTime,paramSubs,eqns,bmat,theS,solveSoln,fRootSoln,hmat,vars}
]

makeSSValSubs[vars_List]:=#[t_]->ToExpression[ToString[#]<>"SSVal"]&/@vars;

$tConst=20
