\documentclass[tikz]{beamer}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\mode<presentation>{}
\usepackage{beamerthemeshadow}

\input{AMArepresentationNewCmds}
\begin{document}
\title[A Series Representation  for Solving  Models]{A Series Representation for Dynamic Economic Model Solutions }
%\subtitle{this is a subtitle}


\author{Gary S. Anderson}
\date{\today\ } 


\frame{\titlepage}

\section{Introduction and Summary}

\begin{frame}

 \begin{itemize}
 \item Proposing a series representation for a broad class of functions
 \item Easy to compute representation for 
families of trajectories
\item Only requires that the trajectories are bounded
\item Originally motivated by solving models occasionally binding constraints
\item Series representation seems much more general flexible than I originally imagined
\end{itemize}
\end{frame}


\begin{frame}
     \begin{itemize}
   \item Today focus on time invariant decision rules 
   \item Representation allows us to split problem of discovering decision rules into two phases
     \begin{itemize}
     \item solving a potentially difficult deterministic problem given a guess for conditional expectations
     \item updating the conditional expectations
   \end{itemize}
     \item occasionally binding constraints
     \item regime switching
\end{itemize}

\end{frame}
\section{The Series Representation}


\subsection{Linear Rational Expectation Solution Preliminaries}

\begin{frame}
  \frametitle{A {\em Linear Reference Model}}
For any linear homogeneous 
$L$ dimensional 
deterministic 
system 
\begin{gather}
  	 H_{-1} x_{t-1} + H_0 x_t + H_1 x_{t+1}=0\label{hSystem}
\end{gather}
with a unique stable solution\citep{anderson10}
\begin{gather}
	 H_{-1} x_{t-1} + H_0 x_t + H_1 x_{t+1}=\psi_\epsilon \epsilon +\psi_{c}\\
x_t=B x_{t-1} + \phi \psi_\epsilon \epsilon + (I - F)^{-1} \phi \psi_c
\intertext{where}
\phi= (H_0 +H_1 B)^{-1}  \text{ and } \,\,F=-\phi H_1 
\end{gather}
Define $\linMod \equiv \linModMats$.
\end{frame}

\begin{frame}
  \frametitle{Bounded Deterministic Paths}

Consider a family of functions:
 \begin{gather}
   \xWarg \in{R^L}\,\,\infNorm{\xWarg}  \le \bar{\mathcal{X}}\,\,\forall t\ > 0 \label{fFamily}.
 \end{gather}
 \begin{itemize}
 \item The $x_{-1}$ is an  $L$ dimensional state vector
 \item $\epsilon$ is a $K$ dimensional ``shock'' vector
 \item  $(x_{-1},\epsilon)$ index individual trajectories for  state vectors.  
 \item No continuity, monotonicity or smoothness required  -- just boundedness
 \item Later will require measurable so that integrals exist
 \end{itemize}

\end{frame}

\begin{frame}
  
{\small
Define 
$  z_{t}(x_{t-1},\epsilon)$ as  %\footnote{These $z$ functions will soon prove useful in an algorithm for computing unknown trajectories like \refeq{fFamily}.}:
{

  \begin{align}
  z_{t}(x_{t-1},\epsilon) \equiv& H_{-1} \mathcal{X}_{t-1}(x_{t-1},\epsilon) + \nonumber\\
& H_0 \mathcal{X}_{t}(x_{t-1},\epsilon) +  \label{defZ} \\
& H_1 \mathcal{X}_{t+1}(x_{t-1},\epsilon). \nonumber
  \end{align}
}}
Then, if $rank(H_1 z_t(x_{t-1},\epsilon)) = rank(z_t(x_{t-1},\epsilon)) \forall t \ge 0$
{\small
	 \begin{gather}
	 \mathcal{X}_{t}(x_{t-1},\epsilon) =B x_{t-1}+ \phi \psi_\epsilon\epsilon + (I - F)^{-1} \phi \psi_c +\\ \sum_{\sForSum=0}^\infty F^s \phi z_{t+\sForSum}(x_{t-1},\epsilon) \label{theSeries}
\intertext{and}
	 \mathcal{X}_{t+k+1}(x_{t-1},\epsilon) =B \mathcal{X}_{t+k} + \sum_{\sForSum =0}^\infty F^\sForSum \phi z_{t+k+\sForSum}(x_{t-1},\epsilon) + (I - F)^{-1} \phi \psi_c \,\,\,\forall t,k \ge  0.
	 \end{gather}
}

\end{frame}

\begin{frame}
\frametitle{Approximating $\mathcal{X}_t(x_{t-1},\epsilon)$} 

{\small

Error two components

\begin{description}
\item[Truncation Error] \ 
  \begin{itemize}
  \item From dropping terms
  \item Low cost to control/eliminate
  \end{itemize}
\item[Discretization Error] \ 
  \begin{itemize}
\item From approximating $z_t$
\item High cost to control depending on dimension of state space
  \end{itemize}

\end{description}
}
\end{frame}


\begin{frame}
\frametitle{Approximating $\mathcal{X}_t(x_{t-1},\epsilon)$} 

{\small

Error two components

\begin{itemize}
\item Truncation Error\footnote{Since
$\sum_{s=k+1}^{\infty} F^s \phi \psi_z = (I -F)^{-1} F^{k+1}\phi \psi_z$}

 	 \begin{gather}
 	 \xWargK \equiv B x_{t-1}+ \phi \psi_\epsilon\epsilon + \sum_{s=0}^k F^s \phi z_{t}(x_{t-1},\epsilon) + (I - F)^{-1} \phi \psi_c \label{theTruncSeries}\\
      \label{eq:1}
\infNorm{\xWarg-\xWargK} \le\\ \infNorm{(I -F)^{-1} F^{k+1}\phi \psi_z} \left ( \infNorm{H_{-1} }+ \infNorm{H_{0} }+ \infNorm{H_{1} } \right )\bar{\mathcal{X}}
    \end{gather}

\item Discretization Error


\end{itemize}

}
\end{frame}

\begin{frame}
  
\subsection{A Simple Example: An ``Almost'' Arbitrary Linear Model and an ``Almost'' Arbitrary Family of Solution Paths}
\label{sec:almostarbitrary}


\frametitle{An ``Almost'' Arbitrary Linear Model}
\begin{gather}
  \begin{bmatrix}
H_{-1}&H_{0}&H_{1} 
  \end{bmatrix}=
\vcenter{\hbox{\includegraphics{refHmat.pdf}}}\intertext{with $\psi_c=\psi_\epsilon=0, \,\,  \psi_z=I$.
the series representation requires that the linear model
have a unique stable solution.}
  B=
\vcenter{\hbox{\includegraphics{refBmat.pdf}}}\\
\phi=
\vcenter{\hbox{\includegraphics{refPhimat.pdf}}}\\
F=
\vcenter{\hbox{\includegraphics{refFmat.pdf}}}
\end{gather} 

\end{frame}
\begin{frame}
  

\begin{figure}
  \centering
\includegraphics[width=1.1in]{piPath.pdf}
\includegraphics[width=1.1in]{oscillPath.pdf}
\includegraphics[width=1.1in]{pseudoPath.pdf}

\includegraphics[width=2in]{theZs.pdf}
\includegraphics[width=2in]{arbTruncErr.pdf}  
\caption{RBC Truncation Error Bound Versus Actual}
  \caption{State Variables and the  z's Corresponding to  $x_{-1}=(1,2,3),\epsilon=(2,1,2)$} \label{arbFig}
\end{figure}

\end{frame}



  \begin{frame}
    
\frametitle{ RBC Model Example}
  See for example\cite{Maliar2005}
 \begin{gather*}
   \max\left \{  u(c_t^t) + E_t \sum_{\tau=t}^\infty \beta \delta^{\tau+1-t}u(c_{\tau+1}^t)\right \}\\
c_\tau^t + k_\tau^{t+1}=(1-d)k_\tau^{t-1} + \theta_\tau f(k_\tau^{t-1})\\
f(k_\tau^{t-1})= k_\tau^\alpha
\intertext{with first order conditions}
\frac{1}{c_t^{\eta}}=\alpha \delta k_{t}^{\alpha-1} E_t \left (\frac{\theta_{t}}{c_{t+1}^\eta} \right ) \\
c_t + k_t=\theta_{t-1}k_{t-1}^\alpha \\
 \theta_t =\theta_{t-1}^\rho e^{\epsilon_t}\label{rbcSys}
 \end{gather*}

  \end{frame}

\begin{frame}
\frametitle{for $\eta=\delta=1$}


\begin{gather}
\frac{1}{c_t}=\alpha \delta k_{t}^{\alpha-1} E_t \left (\frac{\theta_{t}}{c_{t+1}} \right ) \\
c_t + k_t=\theta_{t-1}k_{t-1}^\alpha \\
\theta_t =\theta_{t-1}^\rho e^{\epsilon_t}\label{rbcSys}
\intertext{and there is a closed form solution}
  k_{t}= \alpha \delta \theta_{t} k_{t-1}^\alpha.\label{soln}\\
c_t=  (1-\alpha \delta) \theta_{t} k_{t-1}^\alpha
\end{gather}
  \end{frame}
\begin{frame}


For mean zero iid $\epsilon_t$ we can easily compute a family of trajectories like \refeq{fFamily}
\begin{gather}
  \begin{bmatrix}
c_{t+s}(k_{t-1},\theta_t,\epsilon_t)\\k_{t+s}(k_{t-1},\theta_t,\epsilon_t)    \\ \theta_{t+s}(\theta_{t-1},\theta_t,\epsilon_t)    
  \end{bmatrix}
\intertext{with conditional mean converging over time to }
  \begin{bmatrix}
    c_{ss}\\k_{ss}
  \end{bmatrix}=
  \begin{bmatrix}
\nu^\alpha-\nu\\ \nu
  \end{bmatrix}\intertext{where}
\nu= \alpha ^{\frac{1}{1-\alpha }} \delta ^{\frac{1}{1-\alpha }}
\end{gather}

\end{frame}



  \begin{frame}
    \frametitle{Truncations Errors: Arbitrary System and Linearized System}


\begin{figure}[H]
  \centering
\includegraphics[width=2in]{arbTruncErrSimp.pdf}  
\includegraphics[width=2in]{truncErrSimp.pdf}  
\caption{RBC Model Series Truncation Error Bounds Versus Actual}
  \caption{ $x_{-1}=( {{0.2}, {0.18}, {1.1}}), \epsilon=0.01$} \label{arbFig}
\end{figure}


  \end{frame}
  \begin{frame}
\frametitle{Error Bounds for Proposed Solutions}
    
\begin{itemize}
\item Choose an Almost  Arbitrary Linear Reference Model
\item Compute Truncation Error
\item Construct Augmented Decision Rule Function
\item Compute Discretization Error
\end{itemize}

  \end{frame}


\begin{frame}
  \frametitle{Assess \ADR\  accuracy}
  \begin{itemize}
  \item Exact solution have zero discrepancy
  \item compute deviations  DR approximation error
  \item expectation computation approximation error
  \item series truncation error
  \item don't need to iterate a long path since all the potentials 
errors attainable in first iteration step by searching across initial conditions
  \end{itemize}


\end{frame}

\begin{frame}
  \frametitle{Accuracy Computations Exact Solution}
{\small
  \begin{itemize}
  \item Given an exact solution $x^\star_t=g^\star(x_{t-1},\epsilon_t)$ define
  \begin{gather}
G^\star(x)\equiv\expct{g^\star(x,\epsilon)} \intertext{then with}
E_tx^\star_{t+1}=G^\star(g^\star(x_{t-1},\epsilon_t))\\
    \label{eq:2}
\eqnFunc(x^\star_{t-1},x^\star_t,E_tx^\star_{t+1},\epsilon_t)=0  \,\, \forall  (x_{t-1},\epsilon_t)\\ \intertext{Using $G^\star$ and $\linMod$ construct the family of trajectories and corresponding $z^\star_t(x_{t-1},\epsilon)$ }
   x^\star_t(x_{t-1},\epsilon_t) \in{R^L}\,\,\infNorm{x^\star_t(x_{t-1},\epsilon_t)}  \le \bar{\mathcal{X}}\,\,\forall t\ > 0
  \end{gather}
   \begin{align}
   z^\star_{t}(x_{t-1},\epsilon_t) \equiv& H_{-1}  x^\star_{t-1}(x_{t-1},\epsilon_t) + \nonumber\\
 & H_0  x^\star_{t}(x_{t-1},\epsilon_t) +  \label{defZ} \\
 & H_1  x^\star_{t+1}(x_{t-1},\epsilon_t). \nonumber
   \end{align}

  \end{itemize}
}

\end{frame}

\begin{frame}
  \frametitle{Accuracy Computations Exact Solution}
{\small

  \begin{itemize}
  \item The exact solution has a representation given by
	 \begin{gather}
	 x^\star_{t}(x_{t-1},\epsilon) =B x_{t-1}+ \phi \psi_\epsilon\epsilon + (I - F)^{-1} \phi \psi_c +\\ \sum_{\sForSum=0}^\infty F^s \phi z^\star_{t+\sForSum}(x_{t-1},\epsilon) \intertext{and}
	 \expct{x^\star_{t+1}(x_{t-1},\epsilon)} =B x^\star_{t+k} + \sum_{\sForSum =0}^\infty F^\sForSum \phi \expct{z^\star_{t+1+\sForSum}(x_{t-1},\epsilon)} + (I - F)^{-1} \phi \psi_c 
% \intertext{with}
% \eqnFunc(x_{t-1},x^\star_t,E_tx^\star_{t+1},\epsilon_t)=0  \,\, \forall  (x_{t-1},\epsilon_t)\\ 
	 \end{gather}

  \end{itemize}
}
\end{frame}

\begin{frame}
  \frametitle{Proposed solution}
  \begin{itemize}
  \item Given a proposed solution $x^p_t=g^p(x_{t-1},\epsilon_t)$ define
$G^p(x)\equiv\expct{g^p(x,\epsilon)}$  so that 
  \begin{gather}
E_tx_{t+1}=G^p(g^p(x_{t-1},\epsilon_t))\\
\mathbf{e}_t(x_{t-1},\epsilon)\equiv
\eqnFunc(x_{t-1},x^p_t,E_tx^p_{t+1},\epsilon_t)\\\intertext{Using $G^p$ and $\linMod$ construct the family of trajectories and corresponding $z^p_t(x_{t-1},\epsilon)$ }
   x^p_t(x_{t-1},\epsilon_t) \in{R^L}\,\,\infNorm{x^p_t(x_{t-1},\epsilon_t)}  \le \bar{\mathcal{X}}\,\,\forall t\ > 0
  \end{gather}
   \begin{align}
   z^p_{t}(x_{t-1},\epsilon_t) \equiv& H_{-1}  x^p_{t-1}(x_{t-1},\epsilon_t) + \nonumber\\
 & H_0  x^p_{t}(x_{t-1},\epsilon_t) +  \label{defZ} \\
 & H_1  x^p_{t+1}(x_{t-1},\epsilon_t). \nonumber
   \end{align}
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Proposed solution representation}
  {\small

  \begin{itemize}
  \item The proposed solution has a representation given by 
  \begin{gather}
    \label{eq:4}
	 x^p_{t}(x_{t-1},\epsilon) =B x_{t-1}+ \phi \psi_\epsilon\epsilon + (I - F)^{-1} \phi \psi_c +\\ \sum_{\sForSum=0}^\infty F^s \phi z^p_{t+\sForSum}(x_{t-1},\epsilon) 
 \intertext{and}
 	 \expct{x^p_{t+1}(x_{t-1},\epsilon)} =B x^p_{t+k} + \sum_{\sForSum =0}^\infty F^\sForSum \phi z^p_{t+1+\sForSum}(x_{t-1},\epsilon) + (I - F)^{-1} \phi \psi_c \intertext{with}
\mathbf{e}_t(x_{t-1},\epsilon)\equiv
\eqnFunc(x_{t-1},x^p_t,E_tx^p_{t+1},\epsilon_t)
  \end{gather}

  \end{itemize}
}
\end{frame}



\begin{frame}
  \frametitle{The Difference}
{\small
  \begin{gather}
    \label{eq:3}
\max_{\{x_{-},\epsilon\}} \infNorm{ \phi \eqnFunc(x_{-},g^p(x_{-},\epsilon),G^p(g^p(x_{-},\epsilon)),\epsilon) }\\
\max_{\{x_{-},\epsilon\}} \infNorm{ \phi \expct{ \eqnFunc(x_{-},g^p(x_{-},\epsilon),G^p(g^p(x_{-},\epsilon)),\epsilon)} }\\
\hat{G}^p(x,\epsilon)=G^p(x,\epsilon)+ \mathcal{I}_e(x,\epsilon)\\
\max_{\{x_{-},\epsilon\}} \infNorm{ \phi \expct{ \eqnFunc(x_{-},g^p(x_{-},\epsilon),\hat{G}^p(g^p(x_{-},\epsilon)),\epsilon)} }\\
\max_{\{x_{-},\epsilon\}} \infNorm{ \phi \expct{ \eqnFunc(x_{-},g^p(x_{-},\epsilon),B g^p(x_{-},\epsilon)+(I-F)^{-1}\psi_c,\epsilon)} }\\
	 x^\star_{t}(x_{t-1},\epsilon) -	 x^p_{t}(x_{t-1},\epsilon) =
\sum_{\sForSum=0}^\infty F^s \phi (z^\star_{t+\sForSum}(x_{t-1},\epsilon)-z^p_{t+\sForSum}(x_{t-1},\epsilon))     \\
	 x^\star_{t}(x_{t-1},\epsilon) -	 x^p_{t}(x_{t-1},\epsilon) =
\sum_{\sForSum=0}^\infty F^s \phi \mathbf{z_e}_{t+\sForSum}(x_{t-1},\epsilon_t)   \\ 
	\infNorm{ x^\star_{t}(x_{t-1},\epsilon) -	 x^p_{t}(x_{t-1},\epsilon)} \le
\sum_{\sForSum=0}^\infty F^s \phi \infNorm{\mathbf{z_e}_{t+\sForSum}(x_{t-1},\epsilon_t)}    
  \end{gather}
}
\end{frame}


\begin{frame}
\frametitle{Consider  models that can be written in  the following form}


\begin{gather}
  h_i(x_{t-1},x_{t},x_{t+1},\epsilon_t)=h^{det}_{io}(x_{t-1},x_{t},\epsilon_t)+\\ \sum_{j=1}^{p_i} [h^{det}_{ij}(x_{t-1},x_{t},\epsilon_t)h^{nondet}_{ij}(x_{t},x_{t+1},\epsilon_t)]=0
\end{gather}

\begin{itemize}
\item models where expectations are computed at time t, $\epsilon_t$  known
\item this specification allows use of auxiliary variables for 
accurately computing expected values of nonlinear quantities.
\item if expected lagged values shocks known then deterministic system in L variables
\end{itemize}

\end{frame}


\begin{frame}
\frametitle{the example  model }
\label{sec:simple-rbc-model-ext} can be written as
\begin{gather}
h_{10^{det}}(\cdot)=\frac{1}{c_t},\,\,
h_{11}^{det}()=\alpha \delta k_{t}^{\alpha-1} ,\,\,
h_{11}^{nondet}(\cdot)=E_t \left (\frac{\theta_{t+1}}{c_{t+1}} \right )\\
h_{20}^{det}(\cdot)=c_t + k_t-\theta_tk_{t-1}^\alpha,\,\,
h_{21}^{det}(\cdot)=0\\
h_{30}^{det}(\cdot)=\ln \theta_t -(\rho \ln \theta_{t-1} + \epsilon_t),\,\,
h_{31}^{det}(\cdot)=0
\end{gather}

\end{frame}

\begin{frame}
  \frametitle{Norms, Inner Products}

for all $a \in F$  and all $u, v \in V$
  \begin{itemize}
 \item $\forall v, \someNorm{a v} \ge 0$
 \item $\someNorm{v} =0 \implies v=0$
  \item $\forall v, \someNorm{a v} = |a| \someNorm{v}$
  \item $\forall v_i,v_j \someNorm{v_i} +  \someNorm{v_j} \ge  \someNorm{v_i+v_j}$
  \item for some Hilbert Space and associated  basis functions we can write components of $z_{t+k}^p(x_{t-1},\epsilon)= \sum_{i=1}^\infty w^p_i\varepsilon_i(x_{t-1},\epsilon)$ 
  \item for some finite dimensional space and associated 
 basis functions we can write components of $\hat{z}_{t+k}^p(x_{t-1},\epsilon)= \sum_{i=1}^M w^p_i\varepsilon_i(x_{t-1},\epsilon)$ 
  \end{itemize}
\end{frame}


\begin{frame}
  \frametitle{Some definitions}

{\small

  \begin{description}
  \item[$\numX$-Dimensional Linear Reference Model] \ 

$\linMod \equiv \linModMats$ A linear model with state space of dimension
$\numX$ and unique solutions converging 
to some steady state
  \item[Augmented Decision Rule Function(\ADR)]  \ 
$\xzFunc: \xzFuncSig$ \\
 A function of $
\begin{bmatrix}
  x_{t-1}\\\epsilon_t
\end{bmatrix}
$ providing an approximation 
for $\begin{bmatrix}
  x_t\\z_t
\end{bmatrix}$
  \item[Augmented Decision Rule Conditional Expectation Function(\ADRCE)] 

$\XZFunc: \xzFuncGuessSig$ \\ A function of $x_t$ providing an approximation 
for the conditional expectation  
$\uncnxpt{\begin{bmatrix}
  x_{t+1}\\z_{t+1}
\end{bmatrix}}{x_t}\equiv  \uncnxpt{\xzFunc(x_t,\epsilon_{t+1})}{x_t}$

  \end{description}

}

\end{frame}




\begin{frame}

{\small
  \begin{gather}
  \xzFuncGuess^k \left (
  \begin{bmatrix}
    x_{t-1} \\\epsilon_t
  \end{bmatrix}; \linMod,\xguss
\right )=
  \begin{bmatrix}
    x_{t-1}\\ x_t\\ \xtpguss
  \end{bmatrix}\\
x_t= \sumLinPart + \sumZPartZero +\\  \sumZPartPos(\xguss)  \label{seriesForm}\\ 
\xtpguss=\XZFunc^{k-1}(\xguss) = \sumZPartZero +  \sumZPartPos(\xguss)
  \end{gather}
}
\end{frame}

\begin{frame}
\frametitle{Perfect Foresight}




\begin{gather}
\XZFunc^{k}(x)=     \mathcal{H}^{PF}[\xzFunc^{k}(x,\epsilon_{t+T-k+1})]=\\
\XZFunc^{k}(x)=\EsumLinPart +   \EsumZPartZero\\
 \XZFunc^{k}(x)=\EsumLinPart + \EsumCapZPart{PF}
\end{gather}

\end{frame}
\begin{frame}
  
 \frametitle{Rational Expectations}

 \begin{gather}
 \XZFunc^{k}(x)=     \mathcal{H}^{RE}[\xzFunc^{k}(x,\epsilon_{t+T-k+1})]=
 \expct{\xzFunc^{k}(x,\epsilon_{t+T-k+1})}\\
  \XZFunc^{k}(x)=\EsumLinPart + \EsumZPartEpsilon\\
 \XZFunc^{k}(x)=\EsumLinPart + \EsumCapZPart{RE}
 \end{gather}

\end{frame}


\begin{frame}[fragile]

{\small
%Choose a linear reference  model, $\linMod$, of dimension $\numX$,
%the number of terms for the series $\numTerms$  and interpolation/collocation points,  $\thePts \equiv \thePoints$.
%Choose an initial \ADRCE,  $\XZFunc^0$
}

{\small
  \begin{algorithm}[H]{Compute the \ADR\ $\xzFunc^k(\xtmEpsArg)$ to improve the \ADRCE, $\XZFunc^{k}$}\\
\Input{$\linMod, \XZFunc^k, \numTerms, \thePts,\eqnFunc$}
%\For{(\xtmEpsArg) \in \thePts }{ xx}
\For{$(\xtmEpsArg) \in \thePts$}{
initialize $\xgusst{}= \XZFunc^k(x_{t-1})$\;
\Repeat{$\xlst{t} = \xnxt{t}$}
{$\xlst{t}=\xgusst{}$\\
use $\XZFunc^{k}$ to recursively compute 
$\left \{
\begin{bmatrix}
\xgusst{t+1}\\\zgusst{t+1}
\end{bmatrix}
\cdots
\begin{bmatrix}
\xgusst{t+\numTerms-1}\\  \zgusst{t+\numTerms-1}
\end{bmatrix}
\right \}$\;
use \refeq{seriesForm} to symbolically 
compute $\xzFuncGuess(\xtArg;\xgusst{})$\;
solve $\eqnFunc(\xzFuncGuess(\xtArg;\xgusst{}))$ to determine $\xnxt{t}, \znxt{t}$\;
$\xgusst{}=\xnxt{t}$\;
}
}
$\xzFunc^{k+1}(\xtmEpsArg)\,\,  \forall \, (\xtmEpsArg)\in \thePts \Rightarrow \XZFunc^{k+1} $\;
\Output{$\XZFunc^{k+1}$}
%$\XZFunc^{k+1}(\xtArg)=\int \xzFunc^{k+1}(\xtArg,\epsilon) d\epsilon$

\end{algorithm}
}

\end{frame}


\begin{frame}[fragile]
  \frametitle{\ADR\ and \ADRCE}

{\small
  \begin{itemize}
  \item  $A\equiv \begin{bmatrix}  x_{t-1}\\\epsilon_t\end{bmatrix} \in 
\Rn{\numX+\numEps}$,
$B\equiv \begin{bmatrix}  x_{t}\\z_t\end{bmatrix} \in 
\Rn{\numX+\numZ}$
   \item  $C\equiv \begin{bmatrix}  x_{t} \end{bmatrix}\in 
 \Rn{\numX}$,
 $D\equiv \begin{bmatrix}  x_{t+1}\\z_{t+1}\end{bmatrix} \in 
 \Rn{\numX+\numZ}$
\item $E\equiv \begin{bmatrix}  x_{t-1}\\ x_{t}\\ x_{t+1}\\ \epsilon_t \end{bmatrix}\in 
 \Rn{3\numX+\numEps}$,
$F\equiv \begin{bmatrix}  \eqnErrs \end{bmatrix}\in 
 \Rn{\numX}$
  \end{itemize}


  \begin{tikzcd}
    A \arrow [ r,"\xzFunc"]&B 
  \end{tikzcd}
\begin{tikzcd}
    C \arrow [ r,"\XZFunc"]&D 
  \end{tikzcd}
\begin{tikzcd}
    C \arrow [ r,"\xzFuncGuess"]&B 
  \end{tikzcd}
\begin{tikzcd}
    A \arrow [ r,"\slvr"]&B 
  \end{tikzcd}
\begin{tikzcd}
    E \arrow [ r,"\eqnFunc"]&F 
  \end{tikzcd}

}

\end{frame}



\begin{frame}[fragile]
\frametitle{do generic algorithm}
{\small 


   \begin{tikzcd}
\begin{bmatrix}\epsilon_t\end{bmatrix}&    
\begin{bmatrix}x_{t-1}\end{bmatrix}&
\begin{bmatrix}x_{t}\end{bmatrix}&
\begin{bmatrix}\expct{x_{t+1}}\end{bmatrix}\\
\begin{bmatrix}  z_t\end{bmatrix}
& 
\iSet 
\arrow [ u, "\proj{x_{t-1}}"right ,near end ]   
\arrow [ lu,"\proj{\epsilon_t}" above] 
\arrow[r,"\xzFuncGuess"{name=U,below}]
\arrow [ l,"\proj{z_t}" ] 
& 
\eqnArg 
\arrow[ lu,"\proj{x_{t-1}}" above ]
\arrow[ u,"\proj{x_{t}}"]
\arrow[ ru,"\proj{\expct{x_{t+1}}}", near end,crossing over ]
\arrow[ llu,"\proj{\epsilon_t}" above, near end]
\arrow[ r,"\eqnFunc"]&\eqnOut
\\
\\
&&\mathbf{xz_{in}} 
\arrow[ "gen_{\xzFuncGuess}", to=U] 
\arrow[ld,"\proj{\linMod}"]
\arrow[d,"\proj{\XZFunc}"]
\arrow[rd,"\proj{\xgusst{}}"]
\\
&\linMod&\XZFunc&\begin{bmatrix}\xgusst{}\end{bmatrix}\\
   \end{tikzcd}

}

\end{frame}



\begin{frame}[fragile]
\frametitle{do generic Solver algorithm}
{\small 

   \begin{tikzcd}
\begin{bmatrix}x_{t-1}\end{bmatrix}& 
\iSet
\arrow [ l, "\proj{x_{t-1}}"right ,near end ]   
\arrow [ ld,"\proj{\epsilon_t}" above] 
\arrow[rdd,"\slvr"{name=bip,below}]
& \xzFuncGuessIn
\arrow[l,"\proj{\iSet}"{name=U,below}]
\arrow [ d,"\proj{z_t}" ,near end ] 
\arrow[r,"\xzFuncGuess"{name=rip,below}]
&
\eqnArg 
%\arrow[ rd,"\proj{x_{t}}"]
%\arrow[ lu,"\proj{\expct{x_{t+1}}}", near end,crossing over ]
\arrow[ r,"\eqnFunc"]
&\mathbf{0}
\\
\begin{bmatrix}\epsilon_t\end{bmatrix}
&
% \genSlvrIn 
% \arrow["\genSlvr",to=bip, near start]
% \arrow[d,"\proj{\xzFuncGuess}"]
% \arrow[ld,"\proj{\eqnFunc}"]
&\begin{bmatrix}z_t\end{bmatrix}
\\
&
% \genSlvrIn 
% \arrow["\genSlvr",to=bip]
% \arrow[d,"\proj{\xzFuncGuess}"]
% \arrow[ld,"\proj{\eqnFunc}"]
&
\slvrOut
\arrow[r,"\proj{x_{t}}"]
\arrow[u,"\proj{z_{t}}" right]
&\begin{bmatrix}x_t\end{bmatrix}
\\
&
\genSlvrIn 
\arrow["\genSlvr",to=bip]
\arrow[d,"\proj{\xzFuncGuess}"]
\arrow[ld,"\proj{\eqnFunc}"]
&
&\XZFunc
\arrow["\genXZFunc", from=bip,  bend right=50]
&\genxzFuncGuessIn 
\arrow[ "gen_{\xzFuncGuess}", to=rip] 
\arrow[llld,"gen_{\xzFuncGuess}"] 
\arrow[ld,"\proj{\linMod}"]
\arrow[l,"\proj{\XZFunc}"]
\arrow[lu,"\proj{x_t}"]
\\
\eqnFunc&\xzFuncGuess&&\linMod\\
   \end{tikzcd}

}

\end{frame}



\begin{frame}[fragile]
\frametitle{do generic Fixed Point algorithm}
{\small 

   \begin{tikzcd}
\begin{bmatrix}\epsilon_t\end{bmatrix}&\fpfIn
\arrow[l,"\proj{\epsilon_t}"]
\arrow[ld,"\proj{x_{t-1}}"]
\arrow[r,"\fpf"{name=hip,below}]
&\fpfOut
\arrow[r,"\proj{x_{t}}"]
\arrow[rd,"\proj{z_{t}}"]
&\begin{bmatrix}x_t\end{bmatrix}
\\
\begin{bmatrix}x_{t-1}\end{bmatrix}
&&&\begin{bmatrix}z_t\end{bmatrix}
\\
&\genFpfIn 
\arrow["\genFpf",to=hip]
\arrow[ld,"\proj{\genSlvr}"]
\arrow[d,"\proj{\linMod}"]
\arrow[rd,"\proj{\XZFunc}"]
\arrow[rrd,"\proj{\eqnFunc}"]
\\
\genSlvr &\linMod&\XZFunc&\eqnFunc
   \end{tikzcd}

}

\end{frame}






\begin{frame}
  \frametitle{Parametrized Expectations Algorithm (PEA)}
{\small 
\cite{marcet.lorenzoni99,maliarmovingbounds,juddGSSA2011}

  \begin{gather}
    F (\expct{(\mathcal{E}(y_{t+1}, x_{t+1}, y_t, x_t)), y_t, x_t, \epsilon_t) = 0}\intertext{represent}
\expct{(\mathcal{E} (y_{t+1}, x_{t+1}, y_t, x_t))} \intertext{ by a parametric approximation function, }\Phi(x_t, \theta),\\
F (\Phi(x_t, \theta), y_t, x_t, \epsilon_t) = 0\\
\theta \in  \argmin_{\theta \in \Theta}\mathcal{R}(x_t, \theta)^\prime\Omega\mathcal{R}(x_t,\theta)\\
{R}(x_t, \theta) \equiv \Phi(x_t,\theta)- \expct{(\mathcal{E}(y_{t+1},x_{t+1},y_t,x_t))} 
\intertext{ or}
\theta \in  \argmin_{\theta \in \Theta} 
\twoNorm{ \mathcal{R}(x_t, \theta) }
  \end{gather}
}
\end{frame}

 \begin{frame}
  \frametitle{Stochastic PEA}


    \begin{enumerate}
    \item \ 
      \begin{itemize}
      \item guess initial $\Phi(x_t,\theta)$ by choosing $\theta$. 
      \item choose stopping criterion $\eta>0$
      \item choose sample size T and draw sequence $\{\epsilon_t\}^T_0$
      \end{itemize}
    \item in iteration i for give $\theta^i$ recursively simulate 
$\{y_t(\theta^i)\}^T_0$ and $\{x_t(\theta^i)^T_0\}$
\item perform nonlinear least squares regression to find $G(\theta^i)$ satisfying 
  \begin{gather}
    \hat{\theta} \in \argmin_{\theta \in \Theta} \twoNorm{\Phi(x_t(\theta),\theta)- \expct{(\mathcal{E}(y_{t+1}t(\theta),x_{t+1}(\theta),y_t(\theta),x_t(\theta)))} }
  \end{gather}
\item set $\theta^{i+1} = \gamma \hat{\theta} + (1-\gamma)\theta^i$
\item If $|\theta^{i+1} - \theta^i| < \eta$ then stop otherwise repeat from 2
    \end{enumerate}


 \end{frame}

 \begin{frame}
  \frametitle{Non-Stochastic PEA}


    \begin{enumerate}
    \item \ 
      \begin{itemize}
      \item guess initial $\Phi(x_t,\theta)$ by choosing $\theta$. 
      \item choose stopping criterion $\eta>0$
      \end{itemize}
    \item in iteration i for give $\theta^i$ at each node, compute the conditional expectation
$\expct{\{y_t(\theta^i)\}^T_0}$ and $\expct{\{x_t(\theta^i)^T_0\}}$
\item perform nonlinear least squares regression to find $G(\theta^i)$ satisfying 
  \begin{gather}
    \hat{\theta} \in \argmin_{\theta \in \Theta} \twoNorm{\Phi(x_t(\theta),\theta)- \expct{(\mathcal{E}(y_{t+1}t(\theta),x_{t+1}(\theta),y_t(\theta),x_t(\theta)))} }
  \end{gather}
\item set $\theta^{i+1} = \gamma \hat{\theta} + (1-\gamma)\theta^i$
\item If $|\theta^{i+1} - \theta^i| < \eta$ then stop otherwise repeat from 2
    \end{enumerate}


 \end{frame}

 \begin{frame}
   \frametitle{GSSA}

\cite{juddGSSA2011}
 \begin{description}
\item[Stage 1: Initialization]
  \begin{itemize}
  \item  Choose an initial guess $b^{(1)}$.
 \item Choose the initial state $(k_00,a_0)$ for simulations. 
 \item  Choose a simulation length $T$, draw a sequence of 
  productivity shocks $\{\epsilon_t \}_{t=1\ldots T}$
  \item and compute $\{a_t \}_{t =1\ldots T}$
   \end{itemize}
   \begin{enumerate}
   \item 
 Step 1. At iteration $p$,use $b^(p)$ to simulate the model $T$ periods forward:
 \begin{gather}
 k_{t+1} = \Psi(k_t,a_t;b^{(p)}\\
 c_t = (1 − δ)k_t + a_tf(k_t) − k_{t+1}. 
 \end{gather}

   \end{enumerate}
 \end{description}

 \end{frame}


 \begin{frame}
   \frametitle{GSSA continued}

{\small
   \begin{enumerate}
\setcounter{enumi}{1}
 \item  Step 2. For $t = 0\ldots T − 1$, define $y_t$ to be an approximation of the conditional expectation in (7) using J integration nodes and weights, $\{\epsilon_{t+1,j}j=1\ldots J$ and $\{omega_{t,j}\{j=1\ldots J\}$, respectively:
   \begin{gather}
     y_t=\sum_j^J \left \{ \omega_{t,j}  \gssaKtp \right \}
   \end{gather}
 \item find $\hat{b}$ minimizing the errors $\epsilon_t$ in the regression equation $ y_{t}=\Psi(k_t,a_t;b) + \epsilon$ according to some norm $\someNorm{\cdot}$
\item check for convergence and end Stage 1 if
  \begin{gather}
    \frac{1}{T}\sum_{t=1}^T \left | \frac{k_{t+1}^{(p)}-k_{t+1}^{(p-1)}}{k_{t+1}^{(p)}} \right | < \bar{\omega}
  \end{gather}
 \item compute $b^{(p+1)}= (1-\xi)b^{p)} + \xi \hat{b}$
   \end{enumerate}
}
 \end{frame}


 \begin{frame}
   \frametitle{GSSA continued}

{\small
   \begin{description}
\item[Stage 2]  Test solution
   \end{description}
   \begin{itemize}
\item construct a new set of points $T^{test}$ points $\{k_\tau,a_\tau\}_{\tau=0, \ldots, T^{test}}$
    \item rewrite the Euler equation in the error free form:
      \begin{gather}
        \mathcal{E}(k_\tau,a_\tau)\equiv \expct{
\gssaKtp}_\tau 
      \end{gather}
   \end{itemize}
}
 \end{frame}

\begin{frame}
  \frametitle{Algorithm Operation Counts}
  \begin{description}
  \item[Solve Deterministic Problem]
    \begin{description}
    \item[Expectation Computations] 
    \item[Function Generation] 
    \end{description}
  \end{description}
\end{frame}



\begin{frame}
  \frametitle{RBC Known Solution Truncation Error }
  \begin{description}
  \item[Deterministic Solution] 
  \item[Expectation Computation] 
\item[Function Generation]
  \end{description}

\end{frame}


\begin{frame}
  \frametitle{RBC Unknown Solution Truncation Error }
  \begin{description}
  \item[Deterministic Solution] 
  \item[Expectation Computation] 
\item[Function Generation]
  \end{description}

\end{frame}


\begin{frame}
  \frametitle{RBC Occasionally Binding Constraints Truncation Error }
  \begin{description}
  \item[Deterministic Solution] 
  \item[Expectation Computation] 
\item[Function Generation]
  \end{description}

\end{frame}


\begin{frame}
  \frametitle{RBC Regime Switching Truncation Error }
  \begin{description}
  \item[Deterministic Solution] 
  \item[Expectation Computation] 
\item[Function Generation]
  \end{description}

\end{frame}



\begin{frame}
  \frametitle{RBC Occasionally Binding Constraints and Regime Switching  Truncation Error }
  \begin{description}
  \item[Deterministic Solution] 
  \item[Expectation Computation] 
\item[Function Generation]
  \end{description}

\end{frame}





\begin{frame}
\frametitle{Program Signatures}
\label{sec:program-listings}
\begin{tabular}{|l|c|}
\hline
Number of $x_t$ variables&$\numX$\\
\hline
Number of $z_t$ variables&$\numZ$\\
\hline
Number of $\epsilon_t$ variables&$\numEps$\\
\hline
Number of regimes variables&$\numR$\\
\hline
Number of recursive iterations&$\numIters$\\
\hline
Interpolation Grid Specification&$\dstSpec$\\
\hline
Shock Distributions  Specification&$\dstSpec$\\
\hline
The Linear Reference Model&$\linMod\equiv\linModMats$\\  
\hline
Model Equation Function&$\eqnFuncSig$\\
\hline
\end{tabular}

\end{frame}


\begin{frame}
\frametitle{Solvers}
{\small
\begin{itemize}
\item genFRFunc  -- Mathematica FindRoot for equations alone
\item genNSFunc  -- Mathematica NSolve for equations and inequalities
\end{itemize}
}
  \begin{gather}
\genSlvr:\{\numX,\numEps,\numZ\}\times \xzFunc\times \eqnFunc    \rightarrow\slvr \intertext{ where }
\xzFunc:\xzFuncGuessSig\\
\eqnFunc:\eqnFuncSig\\
    \slvr : \solverSig\\
\slvr \left (
\begin{bmatrix}
  x_{t-1}\\\epsilon
\end{bmatrix}
;\xguss \right ) \rightarrow
\begin{bmatrix}
  x_t\\z_t
\end{bmatrix}
  \end{gather}
\end{frame}

\begin{frame}
  \frametitle{FixedPoint for $\xguss$}
{\small
\begin{gather*}
\genXGFP:\genSlvr\times \linMod \times \{  \XZFunc, \numTerms\} \times \eqnFunc    \rightarrow\\ 
\xgFP : \frfpnsFuncSig\\ \intertext{where}
\XZFunc : \bigXFuncSig\\
\eqnFunc: \eqnFuncSig \intertext{so that}
\xgFP \left (
  \begin{bmatrix}
    x_{t-1}\\ \epsilon_t
  \end{bmatrix}
\right )\rightarrow
\begin{bmatrix}
  x_{t}\\z_{t}
\end{bmatrix}
\end{gather*}
}
\begin{itemize}
\item $\xgFP$ is a function that for a given $\XZFunc^k$ provides $
l  \begin{bmatrix}
    x_{t}\\ z_t
  \end{bmatrix}$ consistent with a $x_{t-1}, \epsilon_t$

\end{itemize}

\end{frame}

\begin{frame}
\frametitle{genLilXkZkFunc}
\label{sec:genlilxkzkfunc}
\begin{gather}
\xzFunc^k(x_{t-1},\epsilon_t):\xzFuncGuessSig\\
\XZFunc^k(x_{t-1})=\expct{ \xzFunc^k(x_{t-1},\epsilon_t):\xzFuncGuessSig}\\
\XZFunc^k(x_{t-1}):\bigXFuncSig\\
\xzFunc^{k+1}(x_{t-1},\epsilon_t):\xzFuncGuessSig\\
  \Gamma_1(\linMod,\{\XZFunc^k,\numTerms\},\xguss)
\end{gather}
{\small
\begin{gather*}
\linMod \times \{  \bigXFuncSig, k \} \times \Rn{(\numX+\numEps)} \rightarrow
\xzFuncGuessSig
\end{gather*}
}
\end{frame}


% \begin{frame}
%   \begin{algorithm}{Improve Augmented Approximate Decision Rule н$\xzFunc(\xNow{})$}
%     \begin{algorithmic}
% x      
%     \end{algorithmic}
%   \end{algorithm}
% \end{frame}



\begin{frame}
\frametitle{genFRFunc,genNSFunc}
\label{sec:genfrfunc}
  \begin{itemize}
  \item use accuracy requirement and truncation error formula to determine number of terms
  \item begin with the linear reference model to construct $xz^0$ and $XZ^0$
  \item construct an initial guess for a next $xz^{k+1}$ func which embeds
for any given $(x_{t-1},\epsilon_t)$ a guess for $x_t$ 
  \item use the solver to solve for tentative $z_t$ and consequently 
a tentative $x_t$ use this as a new guess.  
\item Repeat until guess doesn't change producing  a new $xz^{k+1}$
\item Compute $XZ^{k+1}$
\item Repeat above process until $xz$ and consequently $XZ$ don't change
  \end{itemize}
\end{frame}


\begin{frame}
\frametitle{genFRFunc,genNSFunc}
\begin{gather*}
\{\numX,\numEps,\numZ\}\times(\xzFuncGuessSig)\times (\eqnFuncSig)    \rightarrow\\
\frfpnsFuncSig
\end{gather*}
\end{frame}

\begin{frame}
\frametitle{genFPFunc}
\label{sec:genfpfunc}
\begin{gather*}
\linMod \times \{  \bigXFuncSig, k \} \times (\eqnFuncSig)    \rightarrow\\ 
\frfpnsFuncSig
\end{gather*}

\end{frame}


\begin{frame}
\frametitle{genXZREInterpFunc}
\label{sec:genfpfunc}
\begin{gather*}
\{\numX,\numEps,\numZ\}\times(\xzFuncGuessSig)\times \grdSpec \times  \dstSpec   \rightarrow\\
\bigXFuncSig
\end{gather*}



\end{frame}

\begin{frame}
\frametitle{doIterREInterp}
\label{sec:doiterreinterp}

\begin{gather*}
  \linMod \times 
w\{(\xzFuncGuessSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}  \\
 \times (\eqnFuncSig ) \times \grdSpec \times \dstSpec \rightarrow\\
\{\frfpnsFuncSig, \{(\xzFuncGuessSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}\}
\end{gather*}



\end{frame}



\begin{frame}
\frametitle{nestIterREInterp}
\label{sec:nestiterreinterp}



\begin{gather*}
  \linMod \times 
\{(\xzFuncGuessSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}  \\
 \times (\eqnFuncSig ) \times \grdSpec \times \dstSpec \times \numIters \rightarrow\\
\{\frfpnsFuncSig, \{(\xzFuncGuessSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}\}
\end{gather*}



\end{frame}


\begin{frame}
\frametitle{genLilXkZkRegimeFuncs}
\label{sec:genlilxkzkregimefunc}
{\small
\begin{gather*}
\linMod \times \{(\{  \bigXFuncSig, k_i \})_{k_i=1},\ldots,(\{  \bigXFuncSig, k_i \})_{k_i=\numR}\} \times\\ \Rn{(\numX+\numEps)} \rightarrow\\
\{(\lilXRegimeFuncSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}
\end{gather*}
}





\end{frame}


\begin{frame}
\frametitle{genFRRegimeFuncs, genNSRegimeFuncs}
\label{sec:genfrregimefunc}



{\small
\begin{gather*}
\{\numX,\numEps,\numZ\}\times\\
\{(\lilXRegimeFuncSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}  \\
 \times (\eqnRegimeFuncSig )\rightarrow\\
\frfpnsRegimeFuncSig
\end{gather*}
}








\end{frame}




\begin{frame}
\frametitle{genFPRegimeFuncs}
\label{sec:genfpregimefunc}




{\small
\begin{gather*}
\{\numX,\numEps,\numZ\}\times\\
\{(\lilXRegimeFuncSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}  \\
 \times (\eqnRegimeFuncSig )\rightarrow\\
\frfpnsRegimeFuncSig
\end{gather*}
}




\end{frame}

\begin{frame}
\frametitle{genXZREInterpRegimeFuncs}
\label{sec:genfpfunc}
\begin{gather*}
\{\numX,\numEps,\numZ\}\times(\xzFuncGuessSig)\times \dstSpec \times  \expctSpec   \rightarrow\\
\frfpnsFuncSig
\end{gather*}



\end{frame}


\begin{frame}
\frametitle{doIterREInterpRegime}
\label{sec:doiterreinterp}

\begin{gather*}
  \linMod \times 
\{(\lilXRegimeFuncSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}  \\
 \times (\eqnRegimeFuncSig ) \times \grdSpec \times \dstSpec \rightarrow\\
\{\frfpnsRegimeFuncSig, \{(\lilXRegimeFuncSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}\}
\end{gather*}



\end{frame}

\begin{frame}
\frametitle{nestIterREInterpRegime}
\label{sec:nestiterreinterp}



\begin{gather*}
  \linMod \times 
\{(\lilXRegimeFuncSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}  \\
 \times (\eqnRegimeFuncSig ) \times \grdSpec \times \dstSpec  \times \numIters \rightarrow\\
\{\frfpnsRegimeFuncSig, \{(\lilXRegimeFuncSig)_1,\ldots,(\xzFuncGuessSig)_{\numR}\}\}
\end{gather*}


\end{frame}

\begin{frame}
\frametitle{Representing a Path}

\end{frame}
\begin{frame}
\frametitle{Representing a Family of Paths}

\end{frame}

\begin{frame}
\frametitle{Useful Properties of Series Solution}

\begin{itemize}
\item linear sum of functions
\item far away points matter less
\item Bounds on errors
\end{itemize}



\end{frame}



\begin{frame}
\frametitle{An RBC Model Example}
\end{frame}
\begin{frame}
\frametitle{Known Solution: Conditional Expectations Path}
\begin{itemize}
\item can easily compute series
\item algorithm can recover known solution
\end{itemize}


\end{frame}




\begin{frame}
\frametitle{UnKnown Solution: Conditional Expectations Path}
\begin{itemize}
\item can discover unknown solutions
\end{itemize}



\end{frame}



\begin{frame}
\frametitle{Occasionally Binding Constraints}
\begin{itemize}
\item can discover unknown solutions
\end{itemize}



\end{frame}


\begin{frame}
\frametitle{Regime Switching}
\begin{itemize}
\item can discover unknown solutions
\end{itemize}


\end{frame}

\begin{frame}
\frametitle{Regime Switching with Occasionally Binding Constraints}
\begin{itemize}
\item can discover unknown solutions
\end{itemize}

\end{frame}
\begin{frame}
\frametitle{Future Directions}
\end{frame}



\begin{frame}
  \frametitle{Future Directions}
  \begin{itemize}
  \item factor out expectation function
  \item allow loss function for model error
  \item integration error 
  \item formula applied to finite horizon and continuous time applications weiner stochastic calculus?
  \item multivariate integration
  \item Lusin's theorem one of \href{https://faculty.etsu.edu/gardnerr/5210/notes/3-3.pdf}{littlewood's 3 principles}   and \href{https://www.youtube.com/watch?v=-jOcbJpWttc}{a you tube video}  \href{http://web.maths.unsw.edu.au/~potapov/5825_2013/}{measure theory course }
  \item \href{http://math.stackexchange.com/questions/176379/approximation-of-bounded-measurable-functions-with-continuous-functions}{measurable functions seems like a reasonable requirement for the decision rules}
  \item \href{http://math.stackexchange.com/questions/76931/finding-simple-step-and-continuous-functions-to-satisfy-lebesgue-integral-cond}{integrable function representation}
  \item \href{http://math.stackexchange.com/questions/434239/measurable-function-approximated-by-borel-function}{borel function and measurable function}
  \item \href{http://math.stackexchange.com/questions/573158/approximate-a-complex-measurable-function-pointwisely-almost-everywhere-by-polyn}{polynomials and measurable}
  \item with commit to basis functions, can precompute integrals and 
integration amounts to recomputing linear sum
\item  \href{http://www.mathematica-journal.com/2008/11/dynamic-integration-of-interpolating-functions-and-some-concrete-optimal-stopping-problems/}{another Mathematica streamline for integration}
\item bound on function error leads to bound on error of integral (probably smaller than on function)
  \item rank conditions says that equations that the linear equation
system, through $H_1$,  must depend on expectational terms that can accommodate
errors reflected in $z_T$ 
  \item $(\XZFunc,\numTerms)$
  \item $(\eqnFunc,\{\numX,\numEps,\numZ)$
  \item combine mod dimensions and model equation into same object
  \item provides a distance function or norm can use in contraction proof
  \item Judd, Maliar, Maliar GSSA
  \item representation points should vary by variable and whether expectations or not and then backward looking and other precomputed also more easily precomputed
  \item orthogonal basis
  \item Parametrized expectations algorithm
  \item almost arbitrary must have non zero leads in equations corresponding to model equation with leads -- nonzero columns for F.
  \item Using Parallelization to Solve a Macroeconomic Model: A Parallel Parametrized Expectations Algorithm
Michael Creel
  \item frbus implications/.,mbnvnvbm,.n/.''.jj'.'j;'jjjjj'j;.'''
  \item bound other people's solutions, compare to bound Euler errors
  \item show can determine number series terms then accuracy depends on number of nodes
  \item should normalize h since just scaling up moves bounds around
  \item can precompute z's for exogenous backward looking quantities
  \item evaluation points for XZ and xz need not be the same
  \item model solutions with closed form values produce right series stable difference equations?
  \item add points for interpolation outside range
  \item filter fixed point and findroot failures
  \item add list of solvers to ``try'' if there are fa lures
  \item record performance of solvers using sow reap (functional?)
  \item Heterogeneous Agents Problems
  \item Convergence Properties
    \begin{itemize}
    \item no solution
    \item multiple solutions
    \end{itemize}
\item algorithmic details
  \begin{itemize}
 \item Smolyak nodes
 \item Judd Ergodic region
 \item F small eigenvalues
 \item Projection Methods
 \item Perturbation Methods for initial guess
  \end{itemize}
\item Insights for ``pruning''
  \end{itemize}
\end{frame}

\begin{frame}
  \frametitle{Bibliography}
  \bibliographystyle{plainnat}
\bibliography{../../bibFiles/anderson,../../bibFiles/files}

\end{frame}

\appendix


\end{document}
